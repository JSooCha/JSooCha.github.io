---
title: Heap Tree
excerpt: 자료구조의 이해
categories: Algorithm
tags: [codestates, Java]
toc: true
toc_sticky: true
author_profile: true
sidebar_main: true
published : true
---

## Heap Tree
- 우선순위를 정해 빠르게 자료를 검색하고, 처리할 수 있는 자료구조
- 트리 구조로 구현됨

<br>

### 구조
- 느슨한 정렬 구조
  - 부모 노드의 값은 자식 노드의 값보다 항상 크거나 작게 정렬되어 있지만, 자식 노드끼리는 값의 크기에 따라 좌우 위치를 정렬하지 않음

<br>

### 특징
- 완전 이진트리로 구현 
  - 단순 최대값, 최소값을 찾기 위해 완전 이진트리로 구성할 필요는 없지만, 삽입/삭제 시의 성능을 위함
- 중복 값 저장 가능
  - 단순 최대값/최소값을 찾아내기 위한 구조이기 때문
- 최대 힙 / 최소 힙으로 구현
  - 최대 힙 : 루트 노드에 가장 큰 값이 위치하며 자식 노드로 내려갈수록 작은 값이 위치하게 구현
  - 최소 힙 : 루트 노드에 가장 작은 값이 위치하며, 자식 노드로 내려갈수록 큰 값이 위치하게 구현

<br>

### 데이터 처리 방식
#### 데이터 검색(최대값 / 최소값)

- 최대 힙 / 최소 힙
  - 시간복잡도 : O(1)
    - 항상 루트 노드의 값이 가장 크므로/작으므로, 루트 노드의 값을 불러오면 됨

#### 데이터 삽입

1. 가장 마지막 노드에 새로운 값 저장
2. 삽입된 노드의 값과 부모 노드의 값을 비교
3. 최대 힙일 경우, 부모의 값이 더 크다면 부모의 값과 위치를 서로 변경

더 이상 위치가 바뀌지 않을 때까지 해당 과정을 반복

#### 데이터 삭제

1. 루트 노드의 값 제거
2. 루트 자리에 마지막 노드의 값 삽입
3. 올라간 노드의 값과 그 자식 노드들의 값과 비교
4. 부모보다 더 큰 자식이 있다면(최대 힙) 해당 자식의 값과 서로 교환 
    - 두 자식의 값이 모두 부모보다 작다면, 두 값 중 큰 값과 위치를 변경

더 이상 큰 값이 없을 때까지 반복

<br>

#### 배열로 heap tree 구현
heap tree는 완전 이진트리로 구현되어, 배열로 표현이 가능함

- 완전 이진트리의 특성상 중간에 빈값이 없으므로, 루트 노드부터 순서대로 배열에 정렬 가능
  - 방향은 위에서 아래로, 좌에서 우
- 구현과 노드의 위치를 찾기 쉽게 하기 위해, 일반적으로 배열의 0번째 인덱스는 사용하지 않고, 첫 번째 인덱스부터 사용

![image](https://github.com/JSooCha/JSooCha.github.io/assets/90169862/0431a55d-cd90-4644-a3e8-3ab21ae68a81)

<br>

- 배열로 heap tree를 구현하면, 배열의 크기에 따라 heap tree의 depth가 얼마인지, 부모와 자식 노드의 위치까지도 쉽게 검색 가능
  - depth는 배열의 길이가 1, 3, 7, 15 의 순서대로, 2의 배수를 계속 더한 만큼 늘어남
  - 부모와 자식 노드의 인덱스를 찾는 방법도 수식으로 계산 가능

![image](https://github.com/JSooCha/JSooCha.github.io/assets/90169862/afd662a8-d912-4e04-879a-cb140799a046)

- 현재 노드의 왼쪽 자식 노드의 인덱스 : 현재 노드의 인덱스 * 2
- 현재 노드의 오른쪽 자식 노드의 인덱스 : (현재 노드의 인덱스 * 2) + 1
- 부모의 인덱스 : 자식 노드의 인덱스 / 2 (내림)

<br>

### 실사용 
- 우선순위 큐
- 힙 정렬
