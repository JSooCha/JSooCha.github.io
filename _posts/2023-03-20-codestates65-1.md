---
title: 토큰 기반 자격 증명
excerpt: Session vs. Token
categories: Spring
tags: [codestates, Spring]
toc: true
toc_sticky: true
author_profile: true
sidebar_main: true
published : false
---

## HTTP 프로토콜
- request를 전송한 후, response를 수신하게 되면 연결을 끊는 비 연결성
- request와 response에 대한 상태를 저장하지 않는 비 상태성  
= 로그인 인증에 성공해도 서버 측에서는 request를 수신할 때마다 이 request가 인증된 사용자가 보낸 request인지 알 방법이 없음 -> 인증된 사용자 request의 상태를 유지하기 위한 수단 필요

## 세션(Session)
클라이언트에서 서버의 리소스를 요청하면 서버에서 세션 저장소의 세션 정보와 사용자의 정보가 일치하는지 확인
- 인증된 사용자 정보를 서버 측 세션 저장소에서 세션 형태로 관리
- 세션 ID(생성된 사용자 세션의 고유 ID)는 클라이언트의 쿠키에 저장되어 request 전송 시, 인증된 사용자인지 증명하는 수단으로 사용
- 클라이언트 쪽에서 세션 ID만 사용하므로 상대적으로 적은 네트워크 트래픽 사용
- 서버 측에서 세션 정보를 관리하므로 보안성 측면에서 유리
- 서버의 확장성 면에서는 세션 불일치 문제가 발생할 가능성이 높음   
-> Sticky Session, Session Clustering, Session 저장소의 외부 분리 등의 작업을 통해 보완
- 세션 데이터가 많아질수록 서버의 부담이 가중될 수 있음
- SSR(Server Side Rendering) 방식의 애플리케이션에 적합한 방식

## 토큰(Token)
- 토큰에 포함된 인증된 사용자 정보를 서버 측에서 별도로 관리하지 않음
- 생성된 토큰을 헤더에 포함해 request 전송 시, 인증된 사용자인지를 증명하는 수단으로 사용
- 인증된 사용자 정보를 토큰 내에 포함하므로 세션에 비해 상대적으로 많은 네트워크 트래픽 사용
- 서버 측에서 토큰을 관리하지 않으므로 보안성 측면에서 불리
- 인증된 사용자 request의 상태를 유지할 필요가 없기 때문에 서버의 확장성 면에서 유리하고, 세션 불일치 같은 문제가 발생하지 않음
- 토큰에 포함되는 사용자 정보는 토큰의 특성상 암호화가 되지 않기 때문에 공격자에게 토큰이 탈취될 경우 사용자 정보가 그대로 노출될 수 있음 -> 민감한 정보를 포함하지 말아야 함
- 기본적으로 토큰이 만료되기 전까지는 토큰을 무효화시킬 수 없음  
-> key/value 쌍의 형태로 저장되는 Redis 같은 인메모리 DB에 무효화시키고자 하는 토큰의 만료 시간을 짧게 주어 해당 토큰을 사용하지 못하게 하여 토큰 무효화 문제를 보완
- CSR(Client Side Rendering) 방식의 애플리케이션에 적합한 방식