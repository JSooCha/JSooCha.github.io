---
title: Hash Table
excerpt: 자료구조의 이해
categories: Java
tags: [codestates, Java]
toc: true
toc_sticky: true
author_profile: true
sidebar_main: true
published : true
---

## Hash Table
- 해시함수(hash function)를 사용하여 변환한 해시(hash)를 색인(index)으로 삼아, 키(key)와 데이터(value)를 저장하는 자료구조
  - 필요한 데이터의 키를 해시함수를 사용해 별도의 해시(hash)로 바꿔 주고, 해당하는 데이터를 함께 저장
- e.g. 휴대폰의 단축번호와 같음
  - 김코딩, 010-1234-5678 이라는 데이터를 단축번호 1로 지정하여, 단축번호 1로 바로 전화를 걸 수 있음

![image](https://github.com/JSooCha/JSooCha.github.io/assets/90169862/9dfa0b3c-fac1-48d0-9d4b-650e6236fb65)


<br>

### 구조
- 키(key) : 해시 함수의 입력값이 되는 다양한 길이의 고유 값
  - 해시 함수로 변환하지 않고 저장소에 저장을 하면, 다양한 길이만큼의 저장소를 구성해 두어야 하기 때문에 해시 함수로 값을 바꾸어 저장
- 해시함수(hash Function) : 다양한 길이의 키를 일정한 길이의 해시로 변환
  - 저장소를 효율적으로 운영할 수 있도록 함
  - 해시 충돌을 최대한 줄이는 것이 중요
    - 해시 충돌(hash Collision) : 서로 다른 키가 같은 해시가 되는 경우
- 해시(hash) : 키와 해시함수를 통해 만들어진 값
  - 저장소에서 데이터와 매칭되어 저장
  - 변환된 값을 배열의 색인(index)과 같이 사용
- 데이터(value) : 저장소에 최종적으로 저장되는 값
  - 색인(index)과 매칭되어 저장

<br>

### 특징
- 데이터를 다루는 작업이 매우 빠름
  - 저장, 삭제, 검색 작업이 모두 평균 O(1)의 시간복잡도를 가짐
- 해시 충돌의 위험이 있음
- 데이터 저장 전, 저장공간을 미리 만들어야 하기 떄문에 공간 효율성이 떨어짐
- 해시함수의 의존도가 높음

-> 해시 함수가 복잡하면, 해시값을 만들어내는 데에 많은 시간이 소요됨

#### 저장, 삭제, 검색 과정
- 값을 저장, 삭제, 검색하기 위해서 해시 함수에 키 값을 넣어 해시 값을 생성함
- 이후 만들어진 해시 값과 일치하는 색인을 찾아 저장하거나 삭제, 검색
- 시간복잡도 : O(1)


해시함수를 거쳐 해시 값을 찾아내는데 걸리는 과정은 고려하지 않음 

- 해싱 충돌이 발생할 경우, 저장소의 모든 색인(삽입) 혹은 데이터(삭제, 검색)를 찾아야 함
- 시간복잡도 : O(n)

<br>

### 대표적인 해시 알고리즘
- Division Method : 숫자 타입의 키(key)를 저장소의 크기로 나누어, 나온 나머지를 색인(index)으로 사용하는 방법 
  - 저장소의 크기를 소수(Prime Number)로 정하고, 2의 제곱수와 먼 값을 사용하는 것이 좋음
    - e.g. Key 값이 23일 때, 테이블 크기가 7이라면 index는 2
- Digit Folding : 키(key)의 문자열을 ASCII 코드로 바꾸고, 그 값을 합해 저장소에서 색인(index)으로 사용하는 방법 
  - 색인(index)이 저장소의 크기를 넘어간다면, Division Method 적용 가능
- Multiplication Method : 숫자 타입의 키 값 K, 0 과 1 사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같이 계산한 값을 사용하는 방법
  - index = (KA mod 1)m
- Universal Hashing : 다수의 해시함수를 만들어 특정한 장소에 넣어두고, 무작위로 해시함수를 선택해 해시 값을 만드는 기법

<br>

### 해시 충돌 해결 방법

#### 개방 연결법(Open Addressing)
- 해시 충돌이 발생하면 다른 색인(index)에 해당 자료를 삽입하는 방식 
  - 여러가지 방법이 존재 (여기서는 대표적인 3가지만 기술)
<br>

- Linear Probing : 현재 중복된 색인(index)으로부터, 고정된 숫자만큼 이동하여 비어있는 저장소(버킷)를 찾아 데이터(value) 저장
- Quadratic Probing : 현재 중복된 색인(index)으로부터, 이동할 숫자를 제곱으로 사용하는 방식
  - 처음 충돌이 발생하면 1(1^2)만큼 이동하고, 또 충돌이 발생한다면 4(2^2)만큼, 3번째는 9(3^2)만큼, 4번째는 16(4^2)만큼 이동하여 빈 공간을 탐색하는 방법
- Double Hasing Probing : 하나의 해시함수에서 충돌이 발생하면, 미리 지정해 둔 다른 해시함수를 이용해 새로운 주소를 받아 사용하는 방법
  - 다른 방법들보다 많은 연산 필요

#### 분리 연결법(Separate Chaining)
- 동일한 색인(index)의 데이터에 대해 연결리스트(linked list), 트리(Red-Black tree) 등의 자료구조를 활용해 데이터의 주소를 저장하는 방법
- 구현이 간단하고, 데이터를 쉽게 삭제 가능
- 중복으로 저장되는 데이터가 많아지면, 동일한 버킷에 연결되는 데이터가 많아져 검색의 효율성이 감소함
<br>

![image](https://github.com/JSooCha/JSooCha.github.io/assets/90169862/735942b9-c78a-49ca-9698-39ecd8d2861d)
- 저장소의 동일한 버킷의 데이터에 연결리스트, 트리 등의 자료구조를 사용하여 충돌이 일어난 데이터 저장

<br>

### 저장소 확장(Resize)
- 저장소의 크기가 작으면 불필요한 메모리 사용을 줄일 수 있음
  - 하지만 해시 충돌이 발생하며, 개방 연결법이나 분리 연결법을 사용해도 성능상 손실이 발생함
- Java의 HashMap 자료 구조는 매치된 key-value 데이터 개수가 일정 이상이 된다면(저장소의 75% 이상 사용) 저장소의 크기를 두 배로 늘리게 됨 
  - 이 방식으로 해시 충돌로 인한 성능이 감소하는 문제를 어느 정도 해결 가능

<br>

### 실사용 예제
Address Book(주소록)
Blockchain(블록체인)
자바스크립트 실행 엔진 (크롬, V8)
Domain → DNS 변환
