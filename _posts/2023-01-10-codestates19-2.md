---
title: 자바 가상 머신(Java Virtual Machine)
excerpt: 자바 가상 머신
categories: Java
tags: [codestates, Java]
toc: true
toc_sticky: true
author_profile: true
sidebar_main: true
published : true
---

자바가 탄생하기 이전에는 C++ 이 프로그래밍 언어로 많이 사용되고 있었으나, 운영체제로부터 독립적이지 못하다는 단점을 가지고 있었음

자바는 C++처럼 객체지향 프로그래밍이 가능하면서도, 운영체제로부터 독립되어 있으므로, 자바로 소스 코드를 한 번만 작성하면 어떤 운영체제에서도 코드를 수정할 필요 없이 프로그램을 실행 가능함

이와 같은 운영체제로부터의 독립성은 JVM이라는 별도의 프로그램을 통해서 구현됨

 
## JVM(Java Virtual Machine)
- 자바로 작성한 소스 코드를 해석해 실행하는 별도의 프로그램

### 자바의 독립성이 JVM을 통해 구현되는 과정
- 프로그램이 실행되기 위해 CPU, 메모리, 각종 입출력 장치 등과 같은 컴퓨터 자원을 프로그램이 할당받아야 함
- 운영체제는 가용한 자원을 확인한 다음, 프로그램이 실행되는 데에 필요한 컴퓨터 자원을 프로그램에게 할당해줌
  - 이때, 프로그램이 운영체제에게 필요한 컴퓨터 자원을 요청하는 방식이 운영체제마다 다름
    - 프로그래밍 언어가 운영체제에 대해 종속성을 가지게 되는 이유
- 자바는 JVM을 매개해서 운영체제와 소통함
  - JVM이 자바 프로그램과 운영체제 사이에서 일종의 통역가 역할을 수행
  - JVM은 각 운영체제에 맞게 개발되어 있으며, 자바 소스 코드를 운영 체제에 맞게 변환해 실행시켜 줌
    - 자바가 운영체제로부터 독립적으로 동작할 수 있는 이유

## JVM 구조
jvm구조 사진

- 자바로 소스 코드를 작성하고 실행하면, 먼저 컴파일러가 실행되면서 컴파일이 진행됨
- 컴파일의 결과로 .java 확장자를 가졌던 자바 소스 코드가 .class 확장자를 가진 바이트 코드 파일로 변환됨
- 이후, JVM은 운영 체제로부터 소스 코드 실행에 필요한 메모리를 할당받음
  - 그것이 위 그림 상의 런타임 데이터 영역(Rumtime Data Area)
- 그다음에는 클래스 로더(Class Loader)가 바이트 코드 파일을 JVM 내부로 불러들여 런타임 데이터 영역에 적재시킴
  - 자바 소스 코드를 메모리에 로드시키는 것
- 로드가 완료되면 이제 실행 엔진(Execution Engine)이 런타임 데이터 영역에 적재된 바이트 코드를 실행시킴
- 이때, 실행 엔진은 두 가지 방식으로 바이트 코드를 실행시킴
  - 1 : 인터프리터(Interpreter)를 통해 코드를 한 줄씩 기계어로 번역하고 실행시키기
  - 2 : JIT Compiler(Just-In-Time Compiler)를 통해 바이트 코드 전체를 기계어로 번역하고 실행시키기
- 실행 엔진은 기본적으로 1번의 방법을 통해 바이트 코드를 실행시키다가, 특정 바이트 코드가 자주 실행되면 해당 바이트 코드를 JIT Compiler를 통해 실행시킴
  - 즉, 중복적으로 어떤 바이트 코드가 등장할 때, 인터프리터는 매번 해당 바이트 코드를 해석하고 실행하지만, JIT 컴파일러가 동작하면 한 번에 바이트 코드를 해석하고 실행시킴

[심화 학습](https://deepu.tech/memory-management-in-jvm/)

<br>

## Stack과 Heap
### JVM 메모리 구조
jvm 메모리 구조 사진

- JVM에 Java 프로그램이 로드되어 실행될 때 특정 값 및 바이트코드, 객체, 변수 등과 같은 데이터들이 메모리에 저장되어야 함
  - 런타임 데이터 영역이 바로 이러한 정보를 담는 메모리 영역이며, 크게 5가지 영역으로 구분되어 있음

### Stack 영역
- 일종의 자료구조
  - 프로그램이 데이터를 저장하는 방식
- 후입선출 구조
  - LIFO(Last In First Out)

#### JVM안에서의 Stack
- 메서드가 호출되면 그 메서드를 위한 공간인 Method Frame이 생성됨
- 메서드 내부에서 사용하는 다양한 값들이 있는데 참조변수, 매개변수, 지역변수, 리턴값 및 연산 시 일어나는 값들이 임시로 저장됨
- 이런 Method Frame이 Stack에 호출되는 순서대로 쌓이게 되는데, Method의 동작이 완료되면 역순으로 제거됨

jvm stack 사진

### Heap 영역
- JVM에는 단 하나의 Heap 영역이 존재함
- JVM이 작동되면 이 영역은 자동 생성되며 객체, 인스턴스 변수, 배열이 저장됨

```java
Person person = new Person();
```
- new Person()이 실행되면 Heap 영역에 인스턴스가 생성되며, 인스턴스가 생성된 위치의 주소값을 person에게 할당해 주는데, 이 person은 Stack 영역에 선언된 변수임
- 즉, 객체를 다룬다는 것은 Stack 영역에 저장되어 있는 참조 변수를 통해 Heap 영역에 존재하는 객체를 다룬다는 의미가 됨 
- 정리하자면, Heap 영역은 실제 객체의 값이 저장되는 공간

jvm heap 사진

<br>

## Garbage Collection
자바에서는 가비지 컬렉션이라는 메모리를 자동으로 관리하는 프로세스가 포함되어 있음
- 가비지 컬렉션은 프로그램에서 더 이상 사용하지 않는 객체를 찾아 삭제하거나 제거하여 메모리를 확보하는 것을 의미
```java
Person person = new Person();
person.setName("김코딩");
person = null; 
// 가비지 발생
person = new Person(); 
person.setName("박해커");
```
- 참조 변수 person은 Person 클래스의 인스턴스의 주소값을 할당받고, 이어서 “김코딩”이라는 문자열이 person이 가리키는 인스턴스의 name이라는 속성에 할당됨
- 그런데, 세 번째 줄에서 참조 변수 person에 null이 할당됨으로써, 기존에 person이 가리키던 인스턴스와 참조변수 person 간의 연결이 끊어짐
- 프로그램이 실행 중일 때 이처럼 아무도 인스턴스를 참조하고 있지 않다면, 더 이상 메모리에 person이 가리키던 인스턴스가 존재해야 할 이유가 없음
- 가비지 컬렉터는 이렇게 아무한테도 참조되고 있지 않은 객체 및 변수들을 검색하여 메모리에서 점유를 해제하며, 그럼으로써 메모리 공간을 확보하여 효율적으로 메모리를 사용할 수 있게 해 줌

### 동작 방식
- JVM의 Heap 영역은 객체는 대부분 일회성이며, 메모리에 남아 있는 기간이 대부분 짧다는 전제로 설계되어 있음
- 그러므로 객체가 얼마나 살아있냐에 따라서 Heap 영역 안에서도 영역을 나누게 되는데 Young, Old영역 이렇게 2가지로 나뉨

jvm garbage collection 사진

- Young 영역에서는 새롭게 생성된 객체가 할당되는 곳이고 여기에는 많은 객체가 생성되었다 사라지는 것을 반복함
- 이 영역에서 활동하는 가비지 컬렉터를 Minor GC라고 부름
- Old 영역에서는 Young영역에서 상태를 유지하고 살아남은 객체들이 복사되는 곳으로 보통 Young 영역보다 크게 할당되고 크기가 큰 만큼 가비지는 적게 발생함
- 이 영역에서 활동하는 가비지 컬렉터를 Major GC라고 부름


Young 영역과 Old 영역은 서로 다른 메모리 구조로 되어 있으므로, 세부적인 동작 방식은 다르지만, 기본적으로 가비지 컬렉션이 실행될 때는 다음의 2가지 단계를 따름

1.  Stop The World

Stop The World는 가비지 컬렉션을 실행시키기 위해 JVM이 애플리케이션의 실행을 멈추는 작업임

가비지 컬렉션이 실행될 때 가비지 컬렉션을 실행하는 스레드를 제외한 모든 스레드의 작업은 중단되고, 가비지 정리가 완료되면 재개됨

2. Mark and Sweep

Mark는 사용되는 메모리와 사용하지 않는 메모리를 식별하는 작업을 의미하며, Sweep은 Mark단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업을 의미함

<br>

즉, Stop The World를 통해 모든 작업이 중단되면, 가비지 컬렉션이 모든 변수와 객체를 탐색해서 각각 어떤 객체를 참고하고 있는지 확인함
이후, 사용되고 있는 메모리를 식별해서(Mark) 사용되지 않는 메모리는 제거(Sweep)하는 과정을 진행함