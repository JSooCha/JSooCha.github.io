---
title: 컬렉션 프레임워크
excerpt: 컬렉션에 대한 이해
categories: Java
tags: [codestates, Java]
toc: true
toc_sticky: true
author_profile: true
sidebar_main: true
published : false
---

## 컬렉션 프레임워크(Collection Framework)
- 컬렉션을 편리하게 다루기 위한 메서드들을 정의
  - 컬렉션 : 여러 데이터의 집합

### 컬렉션 프레임워크 구조
![image](https://github.com/JSooCha/JSooCha.github.io/assets/90169862/5e4d98b9-1ff5-482e-9be0-7066d39b3f6c)

- List
  - 데이터의 순서가 유지되며, 중복 저장이 가능한 컬렉션 구현에 사용
  - ArrayList, Vector, Stack, LinkedList 등
- Set
  - 데이터의 순서가 유지되지 않으며, 중복 저장이 불가능한 컬렉션 구현에 사용
  - HashSet, TreeSet 등
- Map
  - 키와 값의 쌍으로 데이터를 저장하는 컬렉션 구현에 사용
  - 데이터의 순서가 유지되지 않으며, 키는 중복 저장이 불가능하지만(값 식별), 값은 중복 저장이 가능
  - HashMap, HashTable, TreeMap, Properties 등
<br>
- List와 Set의 공통점이 추출되어 추상화된 것이  Collection 인터페이스

### Collection 인터페이스의 메서드
#### 객체추가
|리턴 타입|메서드|설명|
|:-:|:-:|:-:|
|boolean|add(Object o) / addAll(Collection c)|주어진 객체 및 컬렉션의 객체들을 컬렉션에 추가|
#### 객체 검색
|리턴 타입|메서드|설명|
|:-:|:-:|:-:|
|boolean|contains(Object o) / containsAll(Collection c)|주어진 객체 및 컬렉션이 저장되어 있는지의 여부를 리턴|
|Iterator|iterator()|컬렉션의 iterator 리턴|
|boolean|equals(Object o)|컬렉션이 동일한지 비교|
|boolean|isEmpty()|컬렉션이 비어있는지 확인|
|int|size()|저장되어 있는 전체 객체 수 리턴|
#### 객체 삭제
|리턴 타입|메서드|설명|
|:-:|:-:|:-:|
|void|clear()|컬렉션에 저장된 모든 객체 삭제|
|boolean|remove(Object o) / removeAll(Collection c)|해당 객체 및 컬렉션을 삭제하고 성공 여부 리턴|
|boolean|retainAll(Collection c)|해당 컬렉션을 제외한 모든 객체를 컬렉션에서 삭제하고, 컬렉션에 변화가 있는지 리턴|
#### 객체 변환
|리턴 타입|메서드|설명|
|:-:|:-:|:-:|
|Object[]|toArray()|컬렉션에 저장된 객체를 객체배열(Object [])로 반환|
|Object[]|toArray(Object[] a)|주어진 배열에 컬렉션의 객체를 저장하고 반환|


### List\<E\>
- 배열과 같이 객체를 일렬로 늘어놓은 구조
- 객체를 저장하면 자동으로 인덱스 부여
- 인덱스로 객체를 검색, 추가, 삭제할 수 있는 여러 기능 제공
- ArrayList, LinkedList, Vector, Stack 등

#### List 인터페이스의 메서드
##### 객체추가
|리턴 타입|메서드|설명|
|:-:|:-:|:-:|
|void|add(int index, Object element)|해당 인덱스에 객체 추가|
|boolean|addAll(int index, Collection c)|해당 인덱스에 컬렉션 추가|
|Object|set(int index, Object element)|해당 위치에 객체 저장|
##### 객체 검색
|리턴 타입|메서드|설명|
|:-:|:-:|:-:|
|Object|get(int index)|해당 인덱스에 저장된 객체 반환|
|int|indexOf(Object o) / lastIndexOf(Object o)|	순방향 / 역방향으로 탐색하여 해당 객체의 위치 반환|
|ListIterator|listIterator() / listIterator(int index)|List의 객체를 탐색할 수 있는 ListIterator 반환 / 주어진 index부터 탐색할 수 있는 ListIterator 반환|
|List|subList(int fromIndex, int toIndex)|	fromIndex부터 toIndex에 있는 객체 반환|
##### 객체 삭제
|리턴 타입|메서드|설명|
|:-:|:-:|:-:|
|Object|remove(int index)|해당 인덱스에 저장된 객체를 삭제하고 삭제된 객체 반환|
|boolean|remove(Object o)|해당 객체 삭제
##### 객체 변환
|리턴 타입|메서드|설명|
|:-:|:-:|:-:|
|void|sort(Comparator c)|주어진 비교자(comparator)로 List 정렬|

#### ArrayList
- List 인터페이스를 구현한 클래스
- Vector보다 주로 ArrayList 사용
  - 기능적으로는 Vector와 동일(기존의 Vector 개선)
- 객체가 인덱스로 관리된다는 점에서는 배열과 유사 
- 저장 용량을 초과하여 객체들이 추가되면, 자동으로 저장용량이 늘어남
  - 배열은 고정된 크기
- 리스트 계열 자료구조의 특성을 이어받아, 데이터가 연속적으로 존재
  - 데이터의 순서 유지

##### ArrayList 사용
```java
ArrayList<타입 매개변수> 객체명 = new ArrayList<타입 매개변수>(초기 저장 용량);

ArrayList<String> container = new ArrayList<String>();
// String 타입의 객체를 저장하는 ArrayList 생성
// 초기 용량이 인자로 전달되지 않으면 기본으로 10 지정
```
- 객체 추가 시, 인덱스 0부터 차례대로 저장되며, 특정 인덱스의 객체를 제거하면, 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨짐
  - 빈번한 객체 삭제와 삽입이 일어나는 경우, ArrayList보다는 LinkedList 사용

```java
public class ArrayListExample {
	public static void main(String[] args) {
		// ArrayList를 생성 후 list에 할당
		ArrayList<String> list = new ArrayList<String>();

		// String 타입의 데이터를 ArrayList에 추가
		list.add("Java");
		list.add("Spring");

		// 저장된 총 객체 수 얻기
		int size = list.size(); 

		// 0번 인덱스의 객체 얻기
		String skill = list.get(0);

		// 저장된 총 객체 수 만큼 조회
		for(int i = 0; i < list.size(); i++){
			String str = list.get(i);
			System.out.println(i + ":" + str);
		}

		// for-each문으로 순회 
		for (String str: list) {
			System.out.println(str);
		}		

		// 0번 인덱스 객체 삭제
		list.remove(0);
	}
}
```

#### LinkedList
- 데이터를 효율적으로 추가, 삭제, 변경하기 위해 사용
- 배열과 달리, 데이터가 불연속적으로 존재
  - 이 데이터들을 서로 연결(link)되어 있음
- 각 요소(node)들은 자신과 연결된 이전 요소 및 다음 요소의 주소값과 데이터로 구성
![image](https://github.com/JSooCha/JSooCha.github.io/assets/90169862/5b9c8ffa-4309-4331-ac89-22a554bceaf2)
- LinkedList에서 데이터를 삭제하려면, 해당 요소의 이전 요소가 해당 요소의 다음 요소를 참조하도록 변경하면 됨
  - 링크를 끊어주는 방식
  - 배열처럼 데이터를 이동하기 위해 복사할 필요가 없기 때문에, 처리 속도가 훨씬 빠름
- 데이터를 추가할 때도 해당 요소를 추가하고자 하는 위치의 이전 요소와 다음 요소 사이에 연결
  - 이전 요소가 새로운 요소를 참조하고, 새로운 요소가 다음 요소를 참조


#### ArrayList와 LinkedList
##### ArrayList
- 데이터 추가, 삭제 시, 다른 데이터를 복사해서 이동해야 함
  - 객체를 순차적으로 저장할 때는 데이터를 이동하지 않아도 되므로 작업 속도가 빠르지만, 중간에 위치한 객체를 추가 및 삭제할 때는 데이터 이동이 많이 일어나므로 속도가 저하됨
- 인덱스가 n인 요소의 주소값을 얻기 위해 ```배열의 주소 + n * 데이터 타입의 크기```를 계산하여 데이터에 빠르게 접근이 가능하기 때문에 검색(읽기) 측면에서는 유리
###### 효율적인 경우
- 데이터를 순차적으로 추가하거나 삭제하는 경우
  - 0번 인덱스에서부터 데이터 추가, 마지막 인덱스에서부터 데이터 삭제
- 데이터를 불러오는 경우
  - 인덱스를 통해 바로 데이터에 접근 가능하므로 속도가 빠름
###### 비효율적인 경우
- 중간에 데이터를 추가, 삭제하는 경우
  - 해당 데이터의 뒤에 위치한 값들을 뒤로 밀어주거나 앞으로 당겨주어야 함

-> 데이터의 개수가 변하지 않는 경우에 사용
###### LinkedList
- 중간의 데이터를 추가, 삭제하는 경우 Next와 Prev에 저장되어 있는 주소값만 변경해주면 됨
  - 데이터의 위치를 당기거나 밀어내지 않아도 되므로, 속도가 빠름
- 데이터 검색 시, 시작 인덱스에서부터 찾고자 하는 데이터까지 순차적으로 각 노드에 접근해야 하므로, 속도가 느림
###### 효율적인 경우
- 중간에 위치하는 데이터를 추가하거나 삭제하는 경우

-> 데이터의 잦은 변경이 예상되는 경우 사용

