---
title: SQL
excerpt: 데이터베이스, SQL
categories: SQL
tags: [codestates, SQL]
toc: true
toc_sticky: true
author_profile: true
sidebar_main: true
published : true
---

## 데이터베이스

### In-Memory
- 프로그램이 실행될 때에만 데이터가 존재하는 저장 방식
- 프로그램의 실행에 의존
  - 프로그램이 종료될 때 데이터도 사라짐 (휘발성)
  - 예기치 못한 상황으로부터 데이터를 보호할 수 없고, 종료된 프로그램에서 데이터를 받아올 수 없음

### File I/O
- 파일을 통해 데이터 저장
  - 엑셀 시트, CSV 등 
    - 해당 파일 형태는 대용량의 데이터를 저장하기 위한 목적이 아님
- 데이터를 불러올 때마다 매번 전체 파일을 읽어야 함
  - 복잡하고 데이터량이 많아질수록 비효율적
    - 손상된 파일, 여러개의 파일을 동시에 다뤄야 하는 경우

### 관계형 데이터베이스 (RDBMS, Relational DataBase Management System)
- 하나의 CSV 파일, 엑셀 시트를 한 개의 테이블로 표현 가능
- 한 번에 여러 개의 테이블을 가질 수 있음
  - SQL을 통해 데이터를 불러오기 수월 

<br>

## SQL (Structured Query Language)
- 관계형 데이터베이스(RDBMS)에서 데이터 관리를 위해 설계된 프로그래밍 언어
  - MySQL, Oracle, SQLite, PostgreSQL 등 
  - 데이터가 구조화된 테이블을 사용하는 데이터베이스(RDBMS)에서만 사용 가능
- 데이터베이스에 쿼리를 보내 데이터를 읽거나 삽입 가능

### 쿼리(query)
- 저장된 데이터를 필터링하기 위한 질의문

### NoSQL (Not Only SQL)
- 비관계형 데이터베이스 
  - 데이터의 구조가 고정되어 있지 않은 데이터베이스
- 테이블 대신, 데이터를 다른 형태로 저장
- 문서 지향 데이터베이스
  - e.g. MongoDB 


<br>

## 기본 쿼리문 

### 데이터베이스 관련

#### 데이터베이스 생성
```sql
CREATE DATABASE 데이터베이스_이름;
```

#### 데이터베이스 사용
데이터베이스를 사용하기 전 해당 명령을 전달해야 함
```sql
USE 데이터베이스_이름;
```

#### 테이블 생성
필드와 함께 생성해야 함

```sql
CREATE TABLE user (
  id int PRIMARY KEY AUTO_INCREMENT,
  name varchar(255),
  email varchar(255)
);
```

#### 테이블 정보 확인
```sql
DESCRIBE user;
```
```
mysql> describe user;
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| id    | int          | NO   | PRI | NULL    | auto_increment |
| name  | varchar(255) | YES  |     | NULL    |                |
| email | varchar(255) | YES  |     | NULL    |                |
+-------+--------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)
```

<br>

- SQL Drop DB
- SQL Drop Table
- SQL Alter Table
- SQL Not Null
- SQL Unique
- SQL Primary Key
- SQL Foreign Key
- SQL Default
- SQL Auto Increment
- SQL Dates

<br>

### 기본 SQL 명령어 (MySQL)

#### SELECT
테이블의 특성 특정
```sql
// 문자열
SELECT 'hello'

// 숫자
SELECT 2

// 간단한 연산
SELECT 1 + 2
```

#### FROM
결과를 찾을 데이터베이스 테이블 명시

```sql
// 특정 특성
SELECT 특성_1
FROM 테이블_이름

// 여러개의 특성 
SELECT 특성_1, 특성_2
FROM 테이블_이름

// 모든 특성. 와일드카드(wildcard) 사용
SELECT *
FROM 테이블_이름
```

#### WHERE
필터 역할을 하는 쿼리문

```sql
// 특정 값과 동일한 데이터
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_1 = "특정 값"

// 특정 값을 제외한 값
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_2 <> "특정 값"

// 특정 값의 크기에 따라 찾기
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_1 > "특정 값"

SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_1 <= "특정 값"

// 특정 값과 비슷한 값 (LIKE, % or *)
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_2 LIKE "%특정 문자열%"

// 리스트의 값들과 일치하는 데이터 (IN)
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_2 IN ("특정값_1", "특정값_2")

// 값이 없는 경우 (IS, NULL)
SELECT *
FROM 테이블_이름
WHERE 특성_1 IS NULL

// 값이 있는 경우 (IS, NOT, NULL)
SELECT *
FROM 테이블_이름
WHERE 특성_1 IS NOT NULL
```

#### ORDER BY
정렬 (기본 : 오름차 순)

```sql
// 오름차순 (ASC)
SELECT *
FROM 테이블_이름
ORDER BY 특성_1 //ASC

// 내림차순 (DESC)
SELECT *
FROM 테이블_이름
ORDER BY 특성_1 DESC
```

#### LIMIT
출력할 데이터의 개수 제한 

```sql
SELECT *
FROM 테이블_이름
LIMIT 200
```

#### DISTINCT
유니크한 값만 선택

```sql
// 특성_1을 기준으로 유니크한 값들만 선택
SELECT DISTINCT 특성_1
FROM 테이블_이름

// 특성_1, 특성_2, 특성_3의 유니크한 조합값들을 선택
SELECT DISTINCT 특성_1, 특성_2, 특성_3 
FROM 테이블_이름
```

#### INNER JOIN (JOIN)

```sql
// 공통된 부분을 기준으로 테이블 연결
SELECT *
FROM 테이블_1
JOIN 테이블_2 ON 테이블_1.특성_A = 테이블_2.특성_B
```

#### OUTER JOIN

```sql
// 좌측 포함(LEFT INCLUSIVE) (LEFT OUTER JOIN)
SELECT *
FROM 테이블_1
LEFT OUTER JOIN 테이블_2 ON 테이블_1.특성_A = 테이블_2.특성_B

// 우측 포함(RIGHT INCLUSIVE) (RIGHT OUTER JOIN)
SELECT *
FROM 테이블_1
RIGHT OUTER JOIN 테이블_2 ON 테이블_1.특성_A = 테이블_2.특성_B
```

<br>

- And, Or, Not
- Insert Into
- Update
- Delete
- Count
- Wildcards
- Aliases
- Group By

<br>

#### 예시
- Brazil에서 온 고객을 도시별로 묶은 뒤에, 각 도시 수에 따라 내림차순 정렬
- CustomerId에 따라 오름차순으로 정렬한 3개의 결과만 출력

```sql
SELECT c.CustomerId, c.FirstName, count(c.City) as 'City Count'
FROM customers AS c
JOIN employees AS e ON c.SupportRepId = e.EmployeeId
WHERE c.Country = 'Brazil'
GROUP BY c.City
ORDER BY 3 DESC, c.CustomerId ASC
LIMIT 3
```





