---
title: Spring Security 기본 구조
excerpt: Spring Security 기본 구조(2)
categories: Spring
tags: [codestates, Spring]
toc: true
toc_sticky: true
author_profile: true
sidebar_main: true
published : true
---

## 회원 가입 폼을 통한 InMemory User 등록

### PasswordEncoder Bean 등록
- PasswordEncoder : Spring Security에서 제공하는 패스워드 암호화 기능을 제공하는 컴포넌트
  - 회원 가입 폼을 통해 애플리케이션에 전달되는 패스워드는 암호화되지 않은 플레인 텍스트(Plain Text)
    - InMemory User로 등록하기 전에 암호화 

```java
@Configuration
public class SecurityConfiguration {
    ...
    ...

    @Bean
    public UserDetailsManager userDetailsService() {
        UserDetails user =
                User.withDefaultPasswordEncoder()
                        .username("kevin@gmail.com")
                        .password("1111")
                        .roles("USER")
                        .build();

        UserDetails admin =
                User.withDefaultPasswordEncoder()
                        .username("admin@gmail.com")
                        .password("2222")
                        .roles("ADMIN")
                        .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder(); 
    }
}
```
<div style = "text-align : center"> PasswordEncoder Bean 등록 </div><br>

- PasswordEncoderFactories.createDelegatingPasswordEncoder()를 통해 DelegatingPasswordEncoder를 먼저 생성 
  - DelegatingPasswordEncode가 PasswordEncoder 구현 객체를 생성
  - userDetailsService() 메서드에서 미리 생성하는 InMemoryUser의 패스워드는 내부적으로 디폴트 PasswordEncoder를 통해 암호화

### MemberService Bean 등록을 위한 JavaConfiguration 구성
```java
public interface MemberService {
    Member createMember(Member member);
}
```
<div style = "text-align : center"> MemberService 인터페이스 </div><br>

```java
public class InMemoryMemberService implements MemberService {
    public Member createMember(Member member) {

        return null;
    }
}
```
<div style = "text-align : center"> InMemory User 등록을 위한 InMemoryMemberService 클래스 </div><br>

```java
@Transactional
public class DBMemberService implements MemberService {
    public Member createMember(Member member) {
         return null;
    }
}
```
<div style = "text-align : center"> 데이터베이스에 User를 등록하기 위한 DBMemberService 클래스 </div><br>

```java
@Configuration
public class JavaConfiguration {
    @Bean
    public MemberService inMemoryMemberService(UserDetailsManager userDetailsManager, 
PasswordEncoder passwordEncoder) {
        return new InMemoryMemberService(userDetailsManager, passwordEncoder);
    }
}
```
<div style = "text-align : center"> MemberService Bean 등록을 위한 JavaConfiguration 구성 </div><br>


- 데이터베이스 연동 없이 메모리에 Spring Security의 User를 등록하고, User 등록 시 패스워드를 암호화하고 등록하기 위한 객체 필요  
  - UserDetailsManager,  PasswordEncoder DI

### InMemoryMemberService 구현
```java
public class InMemoryMemberService implements MemberService {  // (1)
    private final UserDetailsManager userDetailsManager;
    private final PasswordEncoder passwordEncoder;

    // (2)
    public InMemoryMemberService(UserDetailsManager userDetailsManager, PasswordEncoder passwordEncoder) {
        this.userDetailsManager = userDetailsManager;
        this.passwordEncoder = passwordEncoder;
    }

    public Member createMember(Member member) {
        // (3)
        List<GrantedAuthority> authorities = createAuthorities(Member.MemberRole.ROLE_USER.name());

        // (4)
        String encryptedPassword = passwordEncoder.encode(member.getPassword());

        // (5)
        UserDetails userDetails = new User(member.getEmail(), encryptedPassword, authorities);

        // (6)
        userDetailsManager.createUser(userDetails);

        return member;
    }

    private List<GrantedAuthority> createAuthorities(String... roles) {
        // (3-1)
        return Arrays.stream(roles)
                .map(role -> new SimpleGrantedAuthority(role))
                .collect(Collectors.toList());
    }
}
```
- (1) : InMemoryMemberService 클래스는 MemberService 인터페이스를 구현하는 구현 클래스이므로 implements MemberService
  - @Service를 사용하지 않고, JavaConfiguration을 이용해 Bean 등록
- (2) : UserDetailsManager와 PasswordEncoder DI 
  - UserDetailsManager는 Spring Security의 User를 관리하는 관리자 역할
    - SecurityConfiguration 에서 Bean으로 등록한 UserDetailsManager는 InMemoryUserDetailsManager 이므로 여기서 DI 받은 UserDetailsManager 인터페이스의 하위 타입은 InMemoryUserDetailsManager
  - PasswordEncoder 는 Spring Security User를 등록할 때 패스워드를 암호화해 주는 클래스
    - Spring Security 5 에서는 InMemory User도 패스워드의 암호화가 필수   
    따라서 DI 받은 PasswordEncoder 를 이용해 User의 패스워드를 암호화 해주어야 함
- (3) : Spring Security에서 User를 등록하기 위해서는 해당 User의 권한(Authority)을 지정해 주어야 함
  - createAuthorities(Member.MemberRole.ROLE_USER.name());를 이용해 User의 권한 목록을 List\<GrantedAuthority>로 생성
    - Member 클래스에는 MemberRole 이라는 enum이 정의되어 있고, ROLE_USER와 ROLE_ADMIN이라는 enum 타입이 정의되어 있음
  - Spring Security에서는 SimpleGrantedAuthority 를 사용해 Role 베이스 형태의 권한을 지정할 때 ‘ROLE_’ + 권한 명 형태로 지정해 주어야 함. 그렇지 않을 경우 적절한 권한 매핑이 이루어지지 않음
    - (3-1) : Java의 Stream API를 이용해 생성자 파라미터로 해당 User의 Role을 전달하면서 SimpleGrantedAuthority 객체를 생성한 후, List\<SimpleGrantedAuthority> 형태로 리턴
  - (4) : PasswordEncoder 를 이용해 등록할 User의 패스워드를 암호화
    - 패스워드를 암호화하지 않고 User를 등록한다면 User 등록은 되지만 로그인 인증 시, 다음과 같은 에러를 만나게 되므로 User의 패스워드는 반드시 암호화가 필요
  - (5) :  Spring Security User로 등록하기 위한 UserDetails 생성
    -  Spring Security에서는 Spring Security에서 관리하는 User 정보를 UserDetails로 관리
  - (6) : UserDetailsManager의 createUser() 메서드를 이용해서 User를 등록

 회원 가입 메뉴에서 회원 정보를 등록한 후, 등록한 회원 정보로 로그인을 수행하면 정상적으로 로그인이 됨

 ## 데이터베이스 연동을 통한 로그인 인증

 ### Custom UserDetailsService를 사용하는 방법

 #### SecurityConfiguration의 설정 변경 및 추가
- 로그인 인증을 위해 데이터베이스에 저장되어 있는 인증 정보 사용
- InMemory User를 위한 설정들은 더 이상 필요 없으므로 제거
 ```java
 @Configuration
public class SecurityConfiguration {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .headers().frameOptions().sameOrigin() // (1)
            .and()
            .csrf().disable()
            .formLogin()
            .loginPage("/auths/login-form")
            .loginProcessingUrl("/process_login")
            .failureUrl("/auths/login-form?error")
            .and()
            .logout()
            .logoutUrl("/logout")
            .logoutSuccessUrl("/")
            .and()
            .exceptionHandling().accessDeniedPage("/auths/access-denied")
            .and()
            .authorizeHttpRequests(authorize -> authorize
                    .antMatchers("/orders/**").hasRole("ADMIN")
                    .antMatchers("/members/my-page").hasRole("USER")
                    .antMatchers("⁄**").permitAll()
            );
        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }
}
 ```
 (1) : 웹 브라우저에서 H2 웹 콘솔을 정상적으로 사용하기 위한 설정


 #################################





[기본] Hello, Spring Security로 알아보는 Spring Security의 기본 구조 (2)
이전 챕터에서 InMemory User를 이용해 애플리케이션 실행 시, 메모리에 두 개의 사용자 정보를 미리 등록(kevin@gmail.com, admin@gmail.com)한 후 사용자의 권한 별로 request URL의 접근이 제한되는지 여부 등을 살펴보았습니다.


그런데 지난 챕터까지 학습한 내용만으로는 정상적으로 동작하지 않는 기능이 하나 있습니다.

그것은 바로 회원 가입입니다.


여러분들이 일반적으로 생각하기로 회원 가입 후, 가입한 회원 정보로 당연히 로그인을 할 수 있어야 할 텐데 현재 상태로는 회원 가입이 에러 없이 진행되는 것 같지만 가입한 회원 정보로 로그인해 보면 로그인 인증에 실패합니다.


왜 실패할까요?


우리는 아직 Hello Spring Security 샘플 애플리케이션에서 회원 가입 요청으로 전달받은 회원 정보를 Spring Security가 알 수 있는 어떠한 처리도 하지 않았기 때문입니다.


우리가 아직 H2나 MySQL 같은 데이터베이스를 사용하지 않고, 단순히 메모리에 미리 등록한 InMemory User를 사용하고 있지만 애플리케이션이 실행되고 난 이후에도 InMemory User를 추가적으로 등록할 수 있습니다.


이제 무늬만 있는 기능인 회원 가입 기능을 제대로 동작하도록 코드를 수정해 보도록 하겠습니다.



데이터베이스 연동 없는 로그인 인증
```java
package com.codestates.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.provisioning.UserDetailsManager;

@Configuration
public class SecurityConfiguration {
    ...
    ...

    @Bean
    public UserDetailsManager userDetailsService() {
        UserDetails user =
                User.withDefaultPasswordEncoder()
                        .username("kevin@gmail.com")
                        .password("1111")
                        .roles("USER")
                        .build();

        UserDetails admin =
                User.withDefaultPasswordEncoder()
                        .username("admin@gmail.com")
                        .password("2222")
                        .roles("ADMIN")
                        .build();

        return new InMemoryUserDetailsManager(user, admin);
    }
}
```
[코드 4-15] 등록된 두 개의 InMemory User


코드 4-15는 이전 챕터에서 설정한 InMemory User 등록을 위한 코드입니다.

애플리케이션이 실행되면, 코드 4-15의 userDetailsService() 메서드에서 설정한 두 개의 User가 InMemory User로 등록됩니다.


이제 새로운 User를 등록하는 작업을 추가해 봅시다.


⭐ 잊지 마세요❗

여기에서 User 등록은 데이터베이스에 회원 정보를 등록하는 게 아닙니다.

우리는 아직 데이터베이스를 연동하지 않고, Spring Security에서 지원하는 InMemory User를 사용하고 있다는 사실을 기억하세요!


그렇다면 여기서 의미하는 User 등록은?


맞습니다. 바로 메모리에 등록하는 InMemory User입니다.



✅ 회원 가입 폼을 통한 InMemory User 등록
회원 가입 폼을 통해 InMemory User를 등록하기 위한 작업 순서는 다음과 같습니다.

PasswordEncoder Bean 등록

MemberService Bean 등록을 위한 JavaConfiguration 구성

InMemoryMemberService 클래스 구현


1️⃣ PasswordEncoder Bean 등록

PasswordEncoder는 Spring Security에서 제공하는 패스워드 암호화 기능을 제공하는 컴포넌트입니다.

우리가 회원 가입 폼을 통해 애플리케이션에 전달되는 패스워드는 암호화되지 않은 플레인 텍스트(Plain Text)입니다.

따라서 회원 가입 폼에서 전달받은 패스워드는 InMemory User로 등록하기 전에 암호화되어야 합니다.


PasswordEncoder는 다양한 암호화 방식을 제공하며, Spring Security에서 지원하는 PasswordEncoder의 디폴트 암호화 알고리즘은 bcrypt입니다.

PasswordEncoder와 bcrypt 알고리즘에 대해서 더 알아보고 싶다면 아래의 [심화 학습]을 참고하세요.


```java
package com.codestates.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.provisioning.UserDetailsManager;

@Configuration
public class SecurityConfiguration {
    ...
    ...

    @Bean
    public UserDetailsManager userDetailsService() {
        UserDetails user =
                User.withDefaultPasswordEncoder()
                        .username("kevin@gmail.com")
                        .password("1111")
                        .roles("USER")
                        .build();

        UserDetails admin =
                User.withDefaultPasswordEncoder()
                        .username("admin@gmail.com")
                        .password("2222")
                        .roles("ADMIN")
                        .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    // (1)
    @Bean
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();  // (1-1)
    }
}
```
[코드 4-16] PasswordEncoder Bean 등록


코드 4-16에서는 (1)과 같이 SecurityConfiguration 클래스에서 PasswordEncoder를 Bean으로 등록하고 있습니다.


(1-1)의 PasswordEncoderFactories.createDelegatingPasswordEncoder();를 통해 DelegatingPasswordEncoder를 먼저 생성하는데, 이 DelegatingPasswordEncoder가 실질적으로 PasswordEncoder 구현 객체를 생성해 줍니다.


우리가 userDetailsService() 메서드에서 미리 생성하는 InMemoryUser의 패스워드는 내부적으로 디폴트 PasswordEncoder를 통해 암호화된다는 사실을 기억하세요!



2️⃣ MemberService Bean 등록을 위한 JavaConfiguration 구성

여러분들이 섹션 3에서 익숙하게 사용한 MemberService는 클래스이지만 여기서는 학습 목적을 위해 편의상 코드 4-17과 같이 클래스가 아닌 MemberService 인터페이스로 구현합니다.

```java
package com.codestates.member;

public interface MemberService {
    Member createMember(Member member);
}
```
[4-17] MemberService 인터페이스


Hello Spring Security 샘플 애플리케이션은 회원 가입 폼에서 전달받은 정보를 이용해 새로운 사용자를 추가하는 기능만 있으면 되므로 createMember() 하나만 구현하는 구현체가 있으면 됩니다.


이제 이 MemberService 인터페이스를 구현하는 구현 클래스가 있어야 하겠죠?


✔ InMemory User 등록을 위한 InMemoryMemberService 클래스

```java
package com.codestates.member;

public class InMemoryMemberService implements MemberService {
    public Member createMember(Member member) {

        return null;
    }
}
```
[코드 4-18] InMemory User 등록을 위한 InMemoryMemberService 클래스


코드 4-18은 InMemory User를 등록하기 위한 MemberService 인터페이스의 구현 클래스인 InMemoryMemberService 클래스입니다.


InMemoryMemberService 클래스의 createMember()는 잠시 뒤에 구현하도록 하겠습니다.



✔ 데이터베이스에 User를 등록하기 위한 DBMemberService 클래스

```java
package com.codestates.member;

import org.springframework.transaction.annotation.Transactional;

@Transactional
public class DBMemberService implements MemberService {
    public Member createMember(Member member) {
         return null;
    }
}
```
[코드 4-19] 데이터베이스에 User를 등록하기 위한 DBMemberService 클래스


코드 4-19는 데이터베이스에 User를 등록하기 위한 MemberService 인터페이스의 구현 클래스인 DBMemberService 클래스입니다.


DBMemberService 클래스는 InMemory User 등록 학습이 끝난 다음 이어서 바로 구현해 볼 예정이니 조금만 기다려주세요!😊



✔ JavaConfiguration 구성

```java
package com.codestates.config;

import com.codestates.member.InMemoryMemberService;
import com.codestates.member.MemberService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.UserDetailsManager;

@Configuration
public class JavaConfiguration {
    // (1)
    @Bean
    public MemberService inMemoryMemberService(UserDetailsManager userDetailsManager, 
                                               PasswordEncoder passwordEncoder) {
        return new InMemoryMemberService(userDetailsManager, passwordEncoder);
    }
}
```
[코드 4-20] MemberService Bean 등록을 위한 JavaConfiguration 구성


코드 4-20 JavaConfiguration 클래스에서는 MemberService 인터페이스의 구현 클래스인 InMemoryMemberService를 Spring Bean으로 등록합니다.

(1)에서는 MemberService 인터페이스의 구현체인 InMemoryMemberService 클래스의 Bean 객체를 생성합니다.

InMemoryMemberService 클래스는 데이터베이스 연동 없이 메모리에 Spring Security의 User를 등록해야 하므로 UserDetailsManager 객체가 필요합니다.

또한 User 등록 시, 패스워드를 암호화한 후에 등록해야 하므로 Spring Security에서 제공하는 PasswordEncoder 객체가 필요합니다.

따라서 이 두 객체를 InMemoryMemberService 객체 생성 시, DI 해 줍니다.



3️⃣ InMemoryMemberService 구현

```java
package com.codestates.member;

import com.codestates.auth.utils.AuthorityUtils;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.UserDetailsManager;

import java.util.List;

public class InMemoryMemberService implements MemberService {  // (1)
    private final UserDetailsManager userDetailsManager;
    private final PasswordEncoder passwordEncoder;

    // (2)
    public InMemoryMemberService(UserDetailsManager userDetailsManager, PasswordEncoder passwordEncoder) {
        this.userDetailsManager = userDetailsManager;
        this.passwordEncoder = passwordEncoder;
    }

    public Member createMember(Member member) {
        // (3)
        List<GrantedAuthority> authorities = createAuthorities(Member.MemberRole.ROLE_USER.name());

        // (4)
        String encryptedPassword = passwordEncoder.encode(member.getPassword());

        // (5)
        UserDetails userDetails = new User(member.getEmail(), encryptedPassword, authorities);

        // (6)
        userDetailsManager.createUser(userDetails);

        return member;
    }

    private List<GrantedAuthority> createAuthorities(String... roles) {
        // (3-1)
        return Arrays.stream(roles)
                .map(role -> new SimpleGrantedAuthority(role))
                .collect(Collectors.toList());
    }
}
```
[코드 4-21] 메모리에 Spring Security User를 등록해 주는 InMemoryMemberService 클래스


코드 4-21은 회원 가입 정보를 전달받아 Spring Security의 User를 메모리에 등록해 주는 InMemoryMemberService 클래스의 코드입니다.


코드의 설명은 다음과 같습니다.

InMemoryMemberService 클래스는 MemberService 인터페이스를 구현하는 구현 클래스임으로 (1)과 같이 implements MemberService를 지정합니다.

우리가 여태껏 @Service 애너테이션을 사용해 특정 서비스 클래스를 Bean으로 등록하는 방법을 사용해 왔지만 여기서는 @Service을 사용하지 않고, JavaConfiguration을 이용해 Bean을 등록하고 있다는 사실을 기억하기를 바랍니다.


(2)에서는 UserDetailsManager와 PasswordEncoder를 DI 받습니다.

UserDetailsManager는 Spring Security의 User를 관리하는 관리자 역할을 합니다. 우리가 SecurityConfiguration에서 Bean으로 등록한 UserDetailsManager는 InMemoryUserDetailsManager이므로 여기서 DI 받은 UserDetailsManager 인터페이스의 하위 타입은InMemoryUserDetailsManager라는 사실을 기억하기를 바랍니다.

PasswordEncoder는 Spring Security User를 등록할 때 패스워드를 암호화해 주는 클래스입니다.

Spring Security 5에서는 InMemory User도 패스워드의 암호화가 필수입니다. 따라서 DI 받은 PasswordEncoder를 이용해 User의 패스워드를 암호화해 주어야 합니다.


Spring Security에서 User를 등록하기 위해서는 해당 User의 권한(Authority)을 지정해 주어야 합니다.

따라서 (3)의 createAuthorities(Member.MemberRole.ROLE_USER.name());를 이용해 User의 권한 목록을 List<GrantedAuthority>로 생성하고 있습니다.

Member 클래스에는 MemberRole이라는 enum이 정의되어 있고, ROLE_USER와 ROLE_ADMIN이라는 enum 타입이 정의되어 있습니다.

⭐ Spring Security에서는 SimpleGrantedAuthority를 사용해 Role 베이스 형태의 권한을 지정할 때 ‘ROLE_’ + 권한 명 형태로 지정해 주어야 합니다. 그렇지 않을 경우 적절한 권한 매핑이 이루어지지 않는다는 사실을 기억하기를 바랍니다.

(3-1)에서는 Java의 Stream API를 이용해 생성자 파라미터로 해당 User의 Role을 전달하면서 SimpleGrantedAuthority 객체를 생성한 후, List<SimpleGrantedAuthority> 형태로 리턴해 줍니다.

(4)에서는 PasswordEncoder를 이용해 등록할 User의 패스워드를 암호화하고 있습니다.

만약, 패스워드를 암호화하지 않고 User를 등록한다면 User 등록은 되지만 로그인 인증 시, 다음과 같은 에러를 만나게 되므로 User의 패스워드는 반드시 암호화해야 합니다.

java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null”


(5)에서는 Spring Security User로 등록하기 위해 UserDetails를 생성합니다.

⭐ Spring Security에서는 Spring Security에서 관리하는 User 정보를 UserDetails로 관리한다는 사실을 꼭 기억하기를 바랍니다.


(6)에서는 UserDetailsManager의 createUser() 메서드를 이용해서 User를 등록합니다.

이제 애플리케이션을 다시 실행하고 [회원 가입] 메뉴에서 회원 정보를 등록한 후, 등록한 회원 정보(이메일 주소, 패스워드)로 로그인을 수행하면 정상적으로 로그인이 되는 것을 확인할 수 있습니다.



데이터베이스 연동을 통한 로그인 인증
앞에서 살펴본 로그인 인증 방식은 오로지 Spring Security에서 제공하는 InMemory User를 사용하는 인증 방식입니다.


InMemory User는 애플리케이션을 다시 시작하면 메모리에 등록했던 User 정보가 모두 사라지기 때문에 실무에서는 당연히 사용하기 힘들겠죠?


이제 데이터베이스 같은 영구 저장소를 이용해 사용자의 인증 정보를 관리해야 될 시점인 것 같군요.


우리가 여태껏 학습을 위해 만들어보았던 커피 주문 애플리케이션에서 Member 클래스 같은 엔티티 클래스로 회원 정보를 MEMBER 테이블에 저장했듯이 Hello Spring Security 샘플 애플리케이션에서도 간단한 Member 엔티티 클래스를 이용해서 회원의 인증 정보를 포함한 회원 정보를 데이터베이스 테이블에서 관리해 보도록 하겠습니다.


InMemory User를 사용하는 방식은 테스트 환경이나 데모 환경에서 사용할 수 있는 방법입니다.

💡 실무에서 사용하지도 않는 방식을 굳이 왜 설명하느냐고 할 수도 있겠지만 InMemory User를 이용한 로그인 인증에 대해 학습하면서 우리가 Spring Security의 기본 구조와 사용법 등을 단계적으로 익히고 있다는 사실을 꼭 기억하기를 바랍니다.



✅ Custom UserDetailsService를 사용하는 방법
Spring Security에서는 User의 인증 정보를 테이블에 저장하고, 테이블에 저장된 인증 정보를 이용해 인증 프로세스를 진행할 수 있는 몇 가지 방법이 존재하는데 그중 한 가지 방법이 바로 Custom UserDetailsService를 이용하는 방법입니다.


Custom UserDetailsService를 이용해 User의 로그인 인증을 어떻게 처리하는지 지금부터 살펴보도록 하겠습니다.


일반적으로 Spring Security에서는 인증을 시도하는 주체를 User(비슷한 의미로 Principal도 있음)라고 부릅니다.

Principal은 User의 더 구체적인 정보를 의미하며, 일반적으로 Spring Security에서의 Username을 의미합니다.

샘플 애플리케이션에서는 Member 엔티티 클래스가 로그인 인증 정보를 포함할 텐데 이 Member 엔티티가 Spring Security의 User 정보를 포함한다고 보면 됩니다.


1️⃣ SecurityConfiguration의 설정 변경 및 추가

지금부터는 로그인 인증을 위해 데이터베이스에 저장되어 있는 인증 정보를 사용할 것입니다.

따라서 InMemory User를 위한 설정들은 더 이상 필요 없으므로 제거해야 합니다.

```java
package com.codestates.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.provisioning.UserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfiguration {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .headers().frameOptions().sameOrigin() // (1)
            .and()
            .csrf().disable()
            .formLogin()
            .loginPage("/auths/login-form")
            .loginProcessingUrl("/process_login")
            .failureUrl("/auths/login-form?error")
            .and()
            .logout()
            .logoutUrl("/logout")
            .logoutSuccessUrl("/")
            .and()
            .exceptionHandling().accessDeniedPage("/auths/access-denied")
            .and()
            .authorizeHttpRequests(authorize -> authorize
                    .antMatchers("/orders/**").hasRole("ADMIN")
                    .antMatchers("/members/my-page").hasRole("USER")
                    .antMatchers("⁄**").permitAll()
            );
        return http.build();
    }

   // ======================================================== 여기부터
   /**
    * InMemory User를 위한 설정이므로, 제거 대상.
    */
    @Bean
    public UserDetailsManager userDetailsService() {    // (2)
        UserDetails user =
                User.withDefaultPasswordEncoder()
                        .username("kevin@gmail.com")
                        .password("1111")
                        .roles("USER")
                        .build();

        UserDetails admin =
                User.withDefaultPasswordEncoder()
                        .username("admin@gmail.com")
                        .password("2222")
                        .roles("ADMIN")
                        .build();

        return new InMemoryUserDetailsManager(user, admin);
    }
   // ======================================================== 여기까지 제거

    @Bean
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }
}
```
[코드 4-22] 현재 시점까지 사용하고 있는 SecurityConfiguration(V1) 클래스


코드 4-22의 SecurityConfiguration 클래스에서 (1)은 여러분들이 웹 브라우저에서 H2 웹 콘솔을 정상적으로 사용하기 위한 설정입니다.

frameOptions()는 HTML 태그 중에서 \<frame>이나 \<iframe>, \<object> 태그에서 페이지를 렌더링 할지의 여부를 결정하는 기능을 합니다.

Spring Security에서는 Clickjacking 공격을 막기 위해 기본적으로 frameOptions() 기능이 활성화되어 있으며 디폴트 값은 DENY입니다. 즉, 위에서 언급한 HTML 태그를 이용한 페이지 렌더링을 허용하지 않겠다는 의미입니다.

(1)과 같이 .frameOptions().sameOrigin()을 호출하면 동일 출처로부터 들어오는 request만 페이지 렌더링을 허용합니다.

H2 웹 콘솔의 화면 자체가 내부적으로 태그를 사용하고 있으므로 개발 환경에서는 H2 웹 콘솔을 정상적으로 사용할 수 있도록 (1)과 같이 설정하면 됩니다.

Clickjacking 공격에 대해서 더 알아보고 싶은 분은 아래의 [심화 학습]을 참고하세요.


(2)의 userDetailsService() 메서드는 InMemory User를 등록하는 역할을 하지만 이제 데이터베이스에서 User를 등록하고, 데이터베이스에 저장된 User의 인증 정보를 사용할 것이므로 userDetailsService() 메서드를 제거합니다.


2️⃣ JavaConfiguration의 Bean 등록 변경

```java
@Configuration
public class JavaConfiguration {
    // (1)
    @Bean
    public MemberService dbMemberService(MemberRepository memberRepository,
                                         PasswordEncoder passwordEncoder) {
        return new DBMemberService(memberRepository, passwordEncoder); (1-1)
    }
}
```
[코드 4-23] 데이터베이스를 사용하기 위해 변경된 JavaConfiguration 클래스


코드 4-23의 (1)과 같이 데이터베이스에 User의 정보를 저장하기 위해 MemberService 인터페이스의 구현 클래스를 DBMemberService로 변경합니다.

DBMemberService는 내부에서 데이터를 데이터베이스에 저장하고, 패스워드를 암호화해야 하므로 (1-1)과 같이 MemberRepository와 PasswordEncoder 객체를 DI 해줍니다.



3️⃣ DBMemberService 구현

이제 DBMemberService를 구현해 보겠습니다.


DBMemberService는 User의 인증 정보를 데이터베이스에 저장하는 역할을 하는데, 앞에서도 언급했지만 Spring Security 입장에서 User라고 부르는 정보는 우리가 회원 가입 시 등록하는 회원 정보 안에 포함이 되어 있다고 보면 됩니다.


여러분들이 Spring MVC 섹션에서 사용했던 Member 엔티티 클래스를 생각해 보세요. 이 Member 엔티티 클래스의 필드에 인증 정보를 담는 password 필드가 포함된다고 생각하면 되겠습니다.


```java
package com.codestates.member;

import com.codestates.exception.BusinessLogicException;
import com.codestates.exception.ExceptionCode;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Transactional
public class DBMemberService implements MemberService {
    private final MemberRepository memberRepository;
    private final PasswordEncoder passwordEncoder;

    // (1)
    public DBMemberService(MemberRepository memberRepository,
                             PasswordEncoder passwordEncoder) {
        this.memberRepository = memberRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public Member createMember(Member member) {
        verifyExistsEmail(member.getEmail());
        String encryptedPassword = passwordEncoder.encode(member.getPassword());  // (2)
        member.setPassword(encryptedPassword);    // (3)

        Member savedMember = memberRepository.save(member);

        System.out.println("# Create Member in DB");
        return savedMember;
    }
    
    ...
    ...
}
```
[코드 4-24] 회원 정보를 데이터베이스에 등록하는 DBMemberService 클래스


코드 4-24는 회원 정보를 데이터베이스에 저장하는 DBMemberService 클래스의 코드입니다.


코드 설명은 다음과 같습니다.

(1)의 생성자를 통해 MemberRepository와 PasswordEncoder Bean 객체를 DI 받습니다.

(2)에서 PasswordEncoder를 이용해 패스워드를 암호화합니다.

(3)에서 암호화된 패스워드를 password 필드에 다시 할당합니다.


이 외에 나머지 코드는 여러분들이 Spring Data JPA 시간에 학습했던 코드들이기 때문에 설명은 생략하겠습니다.


⭐ 패스워드의 암호화

회원의 패스워드를 암호화해서 데이터베이스에 저장하는 건 개발자 입장에서는 정말 당연한 이야기인데도 불구하고, 회원 등록 로직을 구현할 때 패스워드를 암호화하지 않고 평문(Plain Text) 그대로 저장하는 경우는 실무에서도 종종 볼 수 있는 일입니다.

패스워드 같은 민감한(sensitive) 정보는 반드시 암호화되어 저장되어야 합니다.

꼭 잊지 말아 주세요!

그리고 패스워드는 암호화된 상태에서 복호화할 이유가 없으므로 단방향 암호화 방식으로 암호화되어야 한다는 사실을 꼭 기억하세요!

단방향 암호화에 대해서 더 알아보고 싶다면 아래의 [심화 학습]을 참고하세요.



4️⃣ Custom UserDetailsService 구현

다음으로 데이터베이스에서 조회한 User의 인증 정보를 기반으로 인증을 처리하는 Custom UserDetailsService를 구현해 봅시다.


⭐ UserDetailsService

Spring Security에서 제공하는 컴포넌트 중 하나인 UserDetailsService는 User 정보를 로드(load)하는 핵심 인터페이스입니다.

여기서 로드(load)의 의미는 인증에 필요한 User 정보를 어딘가에서 가지고 온다는 의미이며, 여기서 말하는 ‘어딘가’는 메모리가 될 수도 있고, DB 등의 영구 저장소가 될 수도 있습니다.

우리가 InMemory User를 등록하는 데 사용했던 InMemoryUserDetailsManager는 UserDetailsManager 인터페이스의 구현체이고, UserDetailsManager는 UserDetailsService를 상속하는 확장 인터페이스라는 점 기억하기를 바랍니다.



✔ HelloUserDetailsService

```java
package com.codestates.auth;

import com.codestates.auth.utils.HelloAuthorityUtils;
import com.codestates.exception.BusinessLogicException;
import com.codestates.exception.ExceptionCode;
import com.codestates.member.Member;
import com.codestates.member.MemberRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Optional;

@Component
public class HelloUserDetailsServiceV1 implements UserDetailsService {   // (1)
    private final MemberRepository memberRepository;
    private final HelloAuthorityUtils authorityUtils;

    // (2)
    public HelloUserDetailsServiceV1(MemberRepository memberRepository, HelloAuthorityUtils authorityUtils) {
        this.memberRepository = memberRepository;
        this.authorityUtils = authorityUtils;
    }

    // (3)
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<Member> optionalMember = memberRepository.findByEmail(username);
        Member findMember = optionalMember.orElseThrow(() -> new BusinessLogicException(ExceptionCode.MEMBER_NOT_FOUND));

        // (4)
        Collection<? extends GrantedAuthority> authorities = authorityUtils.createAuthorities(findMember.getEmail());

        // (5)   
        return new User(findMember.getEmail(), findMember.getPassword(), authorities);
    }
}
```
[코드 4-25] 데이터베이스의 인증 정보로 인증을 처리하는 Custom UserDetailsService


코드 4-25는 데이터베이스에서 조회한 인증 정보를 기반으로 인증을 처리하는 Custom UserDetailsService인 HelloUserDetailsService 클래스의 코드입니다.


코드의 설명은 다음과 같습니다.

HelloUserDetailsService와 같은 Custom UserDetailsService를 구현하기 위해서는 (1)과 같이 UserDetailsService 인터페이스를 구현해야 합니다.
HelloUserDetailsService는 V1 ~ V3까지 만들어지기 때문에 각각 클래스를 만들어야 합니다.
HelloUserDetailsService는 데이터베이스에서 User를 조회하고, 조회한 User의 권한(Role) 정보를 생성하기 위해 (2)와 같이 MemberRepository와 HelloAuthorityUtils 클래스를 DI 받습니다.

UserDetailsService 인터페이스를 implements 하는 구현 클래스는 (3)과 같이 loadUserByUsername(String username)이라는 추상 메서드를 구현해야 합니다.

(4)에서는 HelloAuthorityUtils를 이용해 데이터베이스에서 조회한 회원의 이메일 정보를 이용해 Role 기반의 권한 정보(GrantedAuthority) 컬렉션을 생성합니다. (HelloAuthorityUtils 코드는 바로 아래에서 설명합니다)

데이터베이스에서 조회한 인증 정보와 (4)에서 생성한 권한 정보를 Spring Security에서는 아직 알지 못하기 때문에 Spring Security에 이 정보들을 제공해 주어야 하며, (5)에서는 UserDetails 인터페이스의 구현체인 User 클래스의 객체를 통해 제공하고 있습니다.

(5)와 같이 데이터베이스에서 조회한 User 클래스의 객체를 리턴하면 Spring Security가 이 정보를 이용해 인증 절차를 수행합니다.

⭐ 즉, 데이터베이스에서 User의 인증 정보만 Spring Security에 넘겨주고, 인증 처리는 Spring Security가 대신해 줍니다.


⭐ UserDetails

UserDetails는 UserDetailsService에 의해 로드(load)되어 인증을 위해 사용되는 핵심 User 정보를 표현하는 인터페이스입니다.

UserDetails 인터페이스의 구현체는 Spring Security에서 보안 정보 제공을 목적으로 직접 사용되지는 않고, Authentication 객체로 캡슐화되어 제공됩니다.



✔ HelloAuthorityUtils

```java
package com.codestates.auth.utils;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.stereotype.Component;
import java.util.List;

@Component
public class HelloAuthorityUtils {
    // (1)
    @Value("${mail.address.admin}")
    private String adminMailAddress;

    // (2)
    private final List<GrantedAuthority> ADMIN_ROLES = AuthorityUtils.createAuthorityList("ROLE_ADMIN", "ROLE_USER");

    // (3)
    private final List<GrantedAuthority> USER_ROLES = AuthorityUtils.createAuthorityList("ROLE_USER");
    
    public List<GrantedAuthority> createAuthorities(String email) {
        // (4)
        if (email.equals(adminMailAddress)) {
            return ADMIN_ROLES;
        }
        return USER_ROLES;
    }
}
```
[코드 4-26] User의 권한을 매핑, 생성하는 HelloAuthorityUtils


코드 4-26은 HelloUserDetailsService(코드 4-25)에서 Role 기반의 User 권한을 생성하기 위해 사용한 HelloAuthorityUtils 코드입니다.


코드의 설명은 다음과 같습니다.

(1)은 application.yml에 추가한 프로퍼티를 가져오는 표현식입니다.

(1)과 같이 @Value("${프로퍼티 경로}")의 표현식 형태로 작성하면 application.yml에 정의되어 있는 프로퍼티의 값을 클래스 내에서 사용할 수 있습니다.

(1)에서는 application.yml에 미리 정의한 관리자 권한을 가질 수 있는 이메일 주소를 불러오고 있습니다.

application.yml 파일에 정의한 관리자용 이메일 주소는 회원 등록 시, 특정 이메일 주소에 관리자 권한을 부여할 수 있는지를 결정하기 위해 사용됩니다. (4)에서 다시 설명하겠습니다.

💡 application.yml 파일에는 다음과 같이 관리자 이메일 주소를 정의해야 합니다.

```yml
...
...

mail:
  address:
    admin: admin@gmail.com
```

(2)에서는 Spring Security에서 지원하는 AuthorityUtils 클래스를 이용해서 관리자용 권한 목록을 List<GrantedAuthority> 객체로 미리 생성합니다.

관리자 권한의 경우, 일반 사용자의 권한까지 추가로 포함되어 있습니다.

(3)에서는 Spring Security에서 지원하는 AuthorityUtils 클래스를 이용해서 일반 사용 권한 목록을 List<GrantedAuthority> 객체로 미리 생성합니다.

(4)에서는 파라미터로 전달받은 이메일 주소가 application.yml 파일에서 가져온 관리자용 이메일 주소와 동일하다면 관리자용 권한인 List<GrantedAuthority> ADMIN_ROLES를 리턴합니다.


⭐ 실무에서는 당연히 회원 가입 시, 아무런 인증 장치도 없이 이메일 주소만 입력해서 관리자 권한을 부여하지는 않습니다.

관리자 권한은 아무리 강조해도 지나치지 않을 정도로 중요하니까요. 😊

아마도 관리자로서 등록하기 위한 추가적인 인증 절차가 있을 것입니다.

우리는 학습 목적이므로 편의상 이렇게 관리자 권한을 부여한다는 사실을 잊지 마세요!



5️⃣ H2 웹 콘솔에서 등록한 회원 정보 확인 및 로그인 인증 테스트

여러분들이 여기까지 타이핑을 잘했다면 애플리케이션 실행 후, 회원 가입 메뉴에서 회원을 등록한 뒤에 H2 웹 콘솔(http://localhost:8080/h2)에 접속해서 여러분이 등록한 회원 정보를 확인해 보세요.


아래의 [그림 4-10]과 비슷한 화면을 볼 수 있을 겁니다.



[그림 4-10] 인증 정보가 포함된 등록된 회원 정보


우리가 여태껏 사용해 봤던 MEMBER와 큰 차이점은 없습니다.

그런데 [그림 4-10]에서 주목할 부분은 맨 마지막 열인 PASSWORD 열을 보면 회원 가입 메뉴에서 입력했던 패스워드 정보가 암호화 되어있다는 것입니다.


회원의 인증 정보도 잘 등록되어 있으니 이제 로그인 화면에서 등록한 회원의 이메일 주소와 패스워드를 이용해 로그인 해보면 정상적으로 로그인이 되는 걸 확인할 수 있습니다.


application.yml 파일에 정의되어 있는 관리자용 이메일 주소(admin@gmail.com)로도 회원 가입을 한 후, 로그인이 잘 되는지 확인해 보세요! 😊



6️⃣ Custom UserDetails 구현

지금껏 작성한 코드만으로도 데이터베이스에 회원의 인증 정보를 저장하고, 저장된 인증 정보를 기반으로 로그인 인증을 하는 데 큰 문제는 없습니다.


하지만 우리는 조금 더 유연하고 깔끔한 코드의 구성을 위해 앞에서 작성한 HelloUserDetailsService 클래스를 살짝 개선해 보도록 하겠습니다.


✔ 현재까지 작성된 HelloUserDetailsService(V1)

```java
package com.codestates.auth;

import com.codestates.auth.utils.HelloAuthorityUtils;
import com.codestates.exception.BusinessLogicException;
import com.codestates.exception.ExceptionCode;
import com.codestates.member.Member;
import com.codestates.member.MemberRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Optional;

@Component
public class HelloUserDetailsServiceV1 implements UserDetailsService {
    private final MemberRepository memberRepository;
    private final HelloAuthorityUtils authorityUtils;

    public HelloUserDetailsServiceV1(MemberRepository memberRepository, HelloAuthorityUtils authorityUtils) {
        this.memberRepository = memberRepository;
        this.authorityUtils = authorityUtils;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<Member> optionalMember = memberRepository.findByEmail(username);
        Member findMember = optionalMember.orElseThrow(() -> new BusinessLogicException(ExceptionCode.MEMBER_NOT_FOUND));
        Collection<? extends GrantedAuthority> authorities = authorityUtils.createAuthorities(findMember);

        // (1) 개선하면 좋은 포인트
        return new User(findMember.getEmail(), findMember.getPassword(), authorities);
    }
}
```
[코드 4-27] 현재까지 작성된 HelloUserDetailsService(V1)


코드 4-27은 현재까지 작성된 HelloUserDetailsService의 코드입니다.

여기서 개선하면 좋은 부분은 바로 (1)과 같이 UserDetails의 구현 클래스인 User의 객체를 직접적으로 생성해서 리턴하는 부분입니다.


이 부분을 조금 더 유연하고 깔끔하게 작성해 보도록 합시다!



✔ 개선된 HelloUserDetailsService(V2)

```java
package com.codestates.auth;

import com.codestates.auth.utils.HelloAuthorityUtils;
import com.codestates.exception.BusinessLogicException;
import com.codestates.exception.ExceptionCode;
import com.codestates.member.Member;
import com.codestates.member.MemberRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Optional;

@Component
public class HelloUserDetailsServiceV2 implements UserDetailsService {
    private final MemberRepository memberRepository;
    private final HelloAuthorityUtils authorityUtils;

    public HelloUserDetailsServiceV2(MemberRepository memberRepository, HelloAuthorityUtils authorityUtils) {
        this.memberRepository = memberRepository;
        this.authorityUtils = authorityUtils;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<Member> optionalMember = memberRepository.findByEmail(username);
        Member findMember = optionalMember.orElseThrow(() -> new BusinessLogicException(ExceptionCode.MEMBER_NOT_FOUND));

        return new HelloUserDetails(findMember);  // (1) 개선된 부분
    }

    // (2) HelloUserDetails 클래스 추가
    private final class HelloUserDetails extends Member implements UserDetails { // (2-1)
        // (2-2)
        HelloUserDetails(Member member) {
            setMemberId(member.getMemberId());
            setFullName(member.getFullName());
            setEmail(member.getEmail());
            setPassword(member.getPassword());
        }

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            return authorityUtils.createAuthorities(this.getEmail());  // (2-3) 리팩토링 포인트
        }

        // (2-4)
        @Override
        public String getUsername() {
            return getEmail();
        }

        @Override
        public boolean isAccountNonExpired() {
            return true;
        }

        @Override
        public boolean isAccountNonLocked() {
            return true;
        }

        @Override
        public boolean isCredentialsNonExpired() {
            return true;
        }

        @Override
        public boolean isEnabled() {
            return true;
        }
    }

}
```
[코드 4-28] 유연하게 개선된 HelloUserDetailsService(V2)


코드 4-28은 코드 4-27의 코드를 개선한 HelloUserDetailsService(V2)의 코드입니다.


기존에는 loadUserByUsername() 메서드의 리턴 값으로 new User(findMember.getEmail(), findMember.getPassword(), authorities);을 리턴했지만 개선된 코드에서는 (1)과 같이 new HelloUserDetails(findMember);라는 Custom UserDetails 클래스의 생성자로 findMember를 전달하면서 코드가 조금 더 깔끔해졌습니다.

그리고 코드를 유심히 보면 기존에는 loadUserByUsername() 메서드 내부에서 User의 권한 정보를 생성하는 Collection<? extends GrantedAuthority> authorities = authorityUtils.createAuthorities(findMember); 코드가 사라졌습니다.

이 코드는 어디로 갔을까요?

바로 (2)에서 정의한 HelloUserDetails 클래스 내부로 포함되었습니다.


(2)의 HelloUserDetails 클래스는 UserDetails 인터페이스를 구현하고 있고 또한 Member 엔티티 클래스를 상속하고 있습니다.

💡 이렇게 구성하면 데이터베이스에서 조회한 회원 정보를 Spring Security의 User 정보로 변환하는 과정과 User의 권한 정보를 생성하는 과정을 캡슐화할 수 있습니다.

💡 또한 HelloUserDetails 클래스는 Member 엔티티 클래스를 상속하고 있으므로 HelloUserDetails를 리턴 받아 사용하는 측에서는 두 개 클래스의 객체를 모두 다 손쉽게 캐스팅해서 사용 가능하다는 장점이 있습니다.


(2-3)에서는 HelloAuthorityUtils의 createAuthorities() 메서드를 이용해 User의 권한 정보를 생성하고 있습니다.

이 코드는 기존에는 loadUserByUsername() 메서드 내부에 있었지만 지금은 HelloUserDetails 클래스 내부에서 사용되도록 캡슐화되었습니다.


(2-4)에서는 Spring Security에서 인식할 수 있는 username을 Member 클래스의 email 주소로 채우고 있습니다. getUsername()의 리턴 값은 null일 수 없습니다.

기타 UserDetails 인터페이스의 추상 메서드를 구현한 부분은 지금은 크게 중요하지 않은 부분이므로 모두 true값을 리턴하고 있습니다.


7️⃣ User의 Role을 DB에서 관리하기

자, 여러분 이제 Custom UserDetailsService를 이용한 로그인 인증의 마지막 단계입니다.


일반적으로 User의 인증 정보 같은 보안과 관련된 정보는 데이터베이스 같은 영구 저장소에 안전하게 보관합니다.


그런데 현재까지 User의 권한 정보는 데이터베이스에서 관리하는 것이 아니라 데이터베이스에서 조회한 User 정보를 기준으로 코드상에서 조건에 맞게 생성하고 있습니다.


이제 User의 권한 정보를 데이터베이스에서 관리하도록 코드를 수정해 보도록 하겠습니다.


User의 권한 정보를 데이터베이스에서 관리하기 위해서는 다음과 같은 과정이 필요합니다.

User의 권한 정보를 저장하기 위한 테이블 생성

회원 가입 시, User의 권한 정보(Role)를 데이터베이스에 저장하는 작업

로그인 인증 시, User의 권한 정보를 데이터베이스에서 조회하는 작업


이 세 가지 과정을 하나씩 적용해 보도록 하겠습니다.



✔ User의 권한 정보 테이블 생성

User의 권한 정보 테이블을 생성하기 전에 User와 User의 권한 정보 간에 관계를 먼저 생각해야 합니다.


여기서 의미하는 ‘관계’는 테이블 간의 연관 관계를 의미하며, 이 테이블 간의 연관 관계는 우리가 샘플 애플리케이션에서 사용하고 있는 ORM 기술인 JPA를 통해 손쉽게 연관 관계를 맺을 수 있습니다.


이제 JPA를 이용해서 User와 User의 권한 정보 간에 연관 관계를 맺어보겠습니다.


Member

```java
package com.codestates.member;

import com.codestates.audit.Auditable;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import javax.persistence.*;
import java.security.Principal;
import java.util.ArrayList;
import java.util.List;

@NoArgsConstructor
@Getter
@Setter
@Entity
public class Member extends Auditable implements Principal{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long memberId;

    @Column(length = 100, nullable = false)
    private String fullName;

    @Column(nullable = false, updatable = false, unique = true)
    private String email;

    @Column(length = 100, nullable = false)
    private String password;

    @Enumerated(value = EnumType.STRING)
    @Column(length = 20, nullable = false)
    private MemberStatus memberStatus = MemberStatus.MEMBER_ACTIVE;

    // (1) User의 권한 정보 테이블과 매핑되는 정보
    @ElementCollection(fetch = FetchType.EAGER)
    private List<String> roles = new ArrayList<>();

    public Member(String email) {
        this.email = email;
    }

    public Member(String email, String fullName, String password) {
        this.email = email;
        this.fullName= fullName;
        this.password = password;
    }

    @Override
    public String getName() {
        return getEmail();
    }

    public enum MemberStatus {
        MEMBER_ACTIVE("활동중"),
        MEMBER_SLEEP("휴면 상태"),
        MEMBER_QUIT("탈퇴 상태");

        @Getter
        private String status;

        MemberStatus(String status) {
           this.status = status;
        }
    }

    public enum MemberRole {
        ROLE_USER,
        ROLE_ADMIN
    }
}
```
[코드 4-29] Spring Security의 User 역할을 하는 Member 엔티티 클래스에 User 권한 정보 매핑


코드 4-29는 Member 엔티티 클래스와 User의 권한 정보를 매핑한 코드입니다.

Member 엔티티 클래스와 User의 권한 정보를 매핑하는 것은 (1)과 같이 간단하게 처리할 수 있습니다.


(1)과 같이 List, Set 같은 컬렉션 타입의 필드는 @ElementCollection 애너테이션을 추가하면 User 권한 정보와 관련된 별도의 엔티티 클래스를 생성하지 않아도 간단하게 매핑 처리가 됩니다.


즉, 이 상태에서 애플리케이션을 실행하면 아래의 [그림 4-11]과 같은 테이블이 생성됩니다.



[그림 4-11] User의 권한 정보를 저장하는 MEMBER_ROLES 테이블


[그림 4-11]을 보면 Member 엔티티 클래스와 연관 관계 매핑에 대한 테이블이 생성되었습니다.

한 명의 회원이 한 개 이상의 Role을 가질 수 있으므로, MEMBER 테이블과 MEMBER_ROLES 테이블은 1대 N의 관계입니다.


회원 가입을 통해 회원 정보가 MEMBER 테이블에 저장될 때, MEMBER_ROLES 테이블의 MEMBER_MEMBER_ID 열에는 MEMBER 테이블의 기본키 값이 그리고 ROLES 열에는 권한 정보가 저장될 것입니다.




✔ 회원 가입 시, User의 권한 정보(Role)를 데이터베이스에 저장

User의 권한 정보를 관리하는 테이블도 만들어졌으니 이제 회원 가입 시, 해당 회원의 권한 정보를 MEMBER_ROLES 테이블에 저장해 봅시다.


DBMemberService

```java
package com.codestates.member;

import com.codestates.auth.utils.HelloAuthorityUtils;
import com.codestates.exception.BusinessLogicException;
import com.codestates.exception.ExceptionCode;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Transactional
public class DBMemberService implements MemberService {
    ...
    ...
  
    private final HelloAuthorityUtils authorityUtils;

    ...
    ...

    public Member createMember(Member member) {
        verifyExistsEmail(member.getEmail());
        String encryptedPassword = passwordEncoder.encode(member.getPassword());
        member.setPassword(encryptedPassword);

        // (1) Role을 DB에 저장
        List<String> roles = authorityUtils.createRoles(member.getEmail());
        member.setRoles(roles);

        Member savedMember = memberRepository.save(member);

        return savedMember;
    }

    ...
    ...
}
```
[코드 4-30] 회원 등록 시, 권한 정보를 DB에 저장


코드 4-30에서는 DBMemberService에서 회원 등록 시, 회원의 권한 정보를 데이터베이스에 저장하는 코드가 추가되었습니다.


(1)에서는 authorityUtils.createRoles(member.getEmail());를 통해 회원의 권한 정보(List<String> roles)를 생성한 뒤 member 객체에 넘겨주고 있습니다.


아래의 코드 4-31은 createRoles() 메서드가 추가된 HelloAuthorityUtils 클래스의 코드입니다.

```java
package com.codestates.auth.utils;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class HelloAuthorityUtils {
    @Value("${mail.address.admin}")
    private String adminMailAddress;

    ...
    ...

    private final List<String> ADMIN_ROLES_STRING = List.of("ADMIN", "USER");
    private final List<String> USER_ROLES_STRING = List.of("USER");

    ...
    ...

    // (1) DB 저장용
    public List<String> createRoles(String email) {
        if (email.equals(adminMailAddress)) {
            return ADMIN_ROLES_STRING;
        }
        return USER_ROLES_STRING;
    }
}
```
[코드 4-31] 회원의 Role 정보를 생성하는 createRoles() 메서드가 추가된 HelloAuthorityUtils


(1)에서는 파라미터로 전달된 이메일 주소가 application.yml 파일의 mail.address.admin 프로퍼티에 정의된 이메일 주소와 동일하면 관리자 Role 목록(ADMIN_ROLES_STRING)을 리턴하고, 그 외에는 일반 사용자 Role 목록(USER_ROLES_STRING)을 리턴합니다.



✔ 로그인 인증 시, User의 권한 정보를 데이터베이스에서 조회하는 작업

자, 이제 마지막 작업은 로그인 인증에 성공 시, 제공하는 User의 권한 정보를 데이터베이스의 테이블에서 관리되는 Role을 기반으로 생성하는 것입니다.


개선된 HelloUserDetailsService(V3)

```java
package com.codestates.auth;

import com.codestates.auth.utils.HelloAuthorityUtils;
import com.codestates.exception.BusinessLogicException;
import com.codestates.exception.ExceptionCode;
import com.codestates.member.Member;
import com.codestates.member.MemberRepository;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Optional;

@Component
public class HelloUserDetailsServiceV3 implements UserDetailsService {
    private final MemberRepository memberRepository;
    private final HelloAuthorityUtils authorityUtils;

    public HelloUserDetailsServiceV3(MemberRepository memberRepository, HelloAuthorityUtils authorityUtils) {
        this.memberRepository = memberRepository;
        this.authorityUtils = authorityUtils;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<Member> optionalMember = memberRepository.findByEmail(username);
        Member findMember = optionalMember.orElseThrow(() -> new BusinessLogicException(ExceptionCode.MEMBER_NOT_FOUND));

        return new HelloUserDetails(findMember);
    }

    private final class HelloUserDetails extends Member implements UserDetails {
        HelloUserDetails(Member member) {
            setMemberId(member.getMemberId());
            setFullName(member.getFullName());
            setEmail(member.getEmail());
            setPassword(member.getPassword());
            setRoles(member.getRoles());        // (1)
        }

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            // (2) DB에 저장된 Role 정보로 User 권한 목록 생성
            return authorityUtils.createAuthorities(this.getRoles());
        }

        ...
        ...
    }

}
```
[코드 4-32] DB에서 조회한 Role을 기반으로 User의 권한 정보 생성


코드 4-32는 데이터베이스의 MEMBER_ROLES 테이블에서 조회한 Role을 기반으로 User의 권한 목록(List<GrantedAuthority>)을 생성하는 로직이 추가된 HelloUserDetailsService 클래스입니다.


먼저 (1)에서는 HelloUserDetails가 상속하고 있는 Member(extends Member)에 데이터베이스에서 조회한 List<String> roles를 전달합니다.

그리고 (2)에서 다시 Member(extends Member)에 전달한 Role 정보를 authorityUtils.createAuthorities() 메서드의 파라미터로 전달해서 권한 목록(List<GrantedAuthority>)을 생성합니다.


데이터베이스에서 Role 정보를 가지고 오지 않았을 때는 authorityUtils.createAuthorities(this.getRoles());가 아니라 authorityUtils.createAuthorities(this.getEmail());이었습니다.

수정된 부분을 혼동하지 않길 바랍니다.


아래의 코드 4-33은 데이터베이스에서 조회한 Role 정보를 기반으로 User의 권한 목록 생성하는 createAuthorities(List<String> roles) 메서드가 추가된 HelloAuthorityUtils 클래스의 코드입니다.


HelloAuthorityUtils

```java
package com.codestates.auth.utils;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class HelloAuthorityUtils {
    @Value("${mail.address.admin}")
    private String adminMailAddress;

    private final List<GrantedAuthority> ADMIN_ROLES = AuthorityUtils.createAuthorityList("ROLE_ADMIN", "ROLE_USER");
    private final List<GrantedAuthority> USER_ROLES = AuthorityUtils.createAuthorityList("ROLE_USER");
    private final List<String> ADMIN_ROLES_STRING = List.of("ADMIN", "USER");
    private final List<String> USER_ROLES_STRING = List.of("USER");

    // 메모리 상의 Role을 기반으로 권한 정보 생성.
    public List<GrantedAuthority> createAuthorities(String email) {
        if (email.equals(adminMailAddress)) {
            return ADMIN_ROLES;
        }
        return USER_ROLES;
    }

    // (1) DB에 저장된 Role을 기반으로 권한 정보 생성
    public List<GrantedAuthority> createAuthorities(List<String> roles) {
       List<GrantedAuthority> authorities = roles.stream()
               .map(role -> new SimpleGrantedAuthority("ROLE_" + role)) // (2)
               .collect(Collectors.toList());
       return authorities;
    }

    ...
    ...
}
```
[코드 4-33] 데이터베이스에서 조회한 Role 정보를 기반으로 User의 권한 목록 생성


코드 4-33의 (1)을 보면 기존에는 application.yml 파일의 mail.address.admin 프로퍼티에 정의된 관리자용 이메일 주소를 기준으로 관리자 Role을 추가했지만 이제는 그럴 필요가 없습니다.


단순히 데이터베이스에서 가지고 온 Role 목록(List<String> roles)을 그대로 이용해서 권한 목록(authorities)을 만들면 되니까요.


💡 주의해야 할 것은 (2)와 같이 SimpleGrantedAuthority 객체를 생성할 때 생성자 파라미터로 넘겨주는 값이 “ USER" 또는 “ADMIN"으로 넘겨주면 안 되고 “ROLE_USER" 또는 “ROLE_ADMIN" 형태로 넘겨주어야 한다는 것입니다.


이제 애플리케이션을 실행한 뒤 회원 가입 후, 로그인을 해보세요. 잘 동작하나요?

구현에 성공했길 바랍니다.



✅ Custom AuthenticationProvider를 사용하는 방법
앞에서 Custom UserDetailsService를 사용해 로그인 인증을 처리하는 방식은 Spring Security가 내부적으로 인증을 대신 처리해 주는 방식입니다.


이번에는 마지막으로 Custom AuthenticationProvider를 이용해 우리가 직접 로그인 인증을 처리하는 방법을 살펴보도록 하겠습니다.


그냥 Spring Security가 로그인 인증을 대신해 주는 방식을 쓰면 되지 뭣하러 직접 로그인 인증 처리 로직을 만들어야 해?라고 할 수도 있습니다.


물론 Spring Security가 친절하게 대신 인증해 주는 방식을 사용해도 됩니다.


하지만 여러분이 Custom AuthenticationProvider 방식을 사용해 보는 것은 Spring Security의 핵심 컴포넌트인 AuthenticationProvider를 이해하는 데 도움이 되고 또한 보안 요구 사항에 부합하는 적절한 인증 방식(예를 들어 2 Factor 인증 등)을 직접 구현해야 할 경우, Custom AuthenticationProvider가 필요할 수 있습니다.

따라서 이러한 관점으로 아래의 Custom AuthenticationProvider 구현 코드를 살펴보기 바랍니다.


HelloUserAuthenticationProvider(V1)

```java
package com.codestates.auth;

import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Optional;

@Component
public class HelloUserAuthenticationProvider implements AuthenticationProvider {   // (1)
    private final HelloUserDetailsService userDetailsService;
    private final PasswordEncoder passwordEncoder;

    public HelloUserAuthenticationProvider(HelloUserDetailsService userDetailsService, 
                                           PasswordEncoder passwordEncoder) {
        this.userDetailsService = userDetailsService;
        this.passwordEncoder = passwordEncoder;
    }


    // (3)
    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        UsernamePasswordAuthenticationToken authToken = (UsernamePasswordAuthenticationToken) authentication;  // (3-1)

        // (3-2)
        String username = authToken.getName();
        Optional.ofNullable(username).orElseThrow(() -> new UsernameNotFoundException("Invalid User name or User Password"));

        // (3-3)
        UserDetails userDetails = userDetailsService.loadUserByUsername(username);

        String password = userDetails.getPassword();
        verifyCredentials(authToken.getCredentials(), password);    // (3-4)

        Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();  // (3-5)

        // (3-6)
        return UsernamePasswordAuthenticationToken.authenticated(username, password, authorities);
    }

    // (2) HelloUserAuthenticationProvider가 Username/Password 방식의 인증을 지원한다는 것을 Spring Security에 알려준다.
    @Override
    public boolean supports(Class<?> authentication) {
        return UsernamePasswordAuthenticationToken.class.equals(authentication);
    }

    private void verifyCredentials(Object credentials, String password) {
        if (!passwordEncoder.matches((String)credentials, password)) {
            throw new BadCredentialsException("Invalid User name or User Password");
        }
    }
}
```
[코드 4-34] Custom AuthenticationProvider인 HelloUserAuthenticationProvider


코드 4-34는 AuthenticationProvider를 HelloUserAuthenticationProvider의 코드입니다.


코드 4-34의 설명은 다음과 같습니다.

(1)과 같이 AuthenticationProvider 인터페이스의 구현 클래스로 정의합니다.

따라서 우리는 AuthenticationProvider의 구현 클래스로써의 HelloUserAuthenticationProvider를 구현해야 합니다.

Spring Security는 코드 4-34와 같이 AuthenticationProvider를 구현한 구현 클래스가 Spring Bean으로 등록되어 있다면 해당 AuthenticationProvider를 이용해서 인증을 진행합니다.

따라서 클라이언트 쪽에서 로그인 인증을 시도하면 우리가 구현한 HelloUserAuthenticationProvider가 직접 인증을 처리하게 됩니다.


AuthenticationProvider 인터페이스의 구현 클래스는 authenticate(Authentication authentication) 메서드와 supports(Class<?> authentication) 메서드를 구현해야 합니다.

그중에서 (2)의 supports(Class<?> authentication) 메서드는 우리가 구현하는 Custom AuthenticationProvider(HelloUserAuthenticationProvider)가 Username/Password 방식의 인증을 지원한다는 것을 Spring Security에 알려주는 역할을 합니다.

supports() 메서드의 리턴값이 true일 경우, Spring Security는 해당 AuthenticationProvider의 authenticate() 메서드를 호출해서 인증을 진행합니다.


(3)의 authenticate(Authentication authentication)에서 우리가 직접 작성한 인증 처리 로직을 이용해 사용자의 인증 여부를 결정합니다.

(3-1)에서 authentication을 캐스팅하여 UsernamePasswordAuthenticationToken을 얻습니다.

이 UsernamePasswordAuthenticationToken 객체에서 (3-2)와 같이 해당 사용자의 Username을 얻은 후, 존재하는지 체크합니다.

Username이 존재한다면 (3-3)과 같이 userDetailsService를 이용해 데이터베이스에서 해당 사용자를 조회합니다.

(3-4)에서 로그인 정보에 포함된 패스워드(authToken.getCredentials())와 데이터베이스에 저장된 사용자의 패스워드 정보가 일치하는지를 검증합니다.

(3-4)의 검증 과정을 통과했다면 로그인 인증에 성공한 사용자이므로 (3-5)와 같이 해당 사용자의 권한을 생성합니다.

마지막으로 (3-6)과 같이 인증된 사용자의 인증 정보를 리턴값으로 전달합니다.

이 인증 정보는 내부적으로 Spring Security에서 관리하게 됩니다.


이제 애플리케이션을 다시 실행하고 회원 가입을 한 후, 로그인을 해 보세요.

회원 가입 시 등록한 이메일 주소/패스워드를 올바르게 입력하면 정상적으로 Hello, Spring Security의 메인 화면이 브라우저에 표시할 것입니다.

그런데 만약 회원 가입을 하지 않고 로그인을 시도할 경우(회원 가입 이후에는 상관없습니다) 인증에 실패하고, 아래의 [그림 4-11-1]과 같은 하얀 에러 화면을 만나게 됩니다.



[그림 4-11-1] HelloAuthenticationProvider를 통한 인증 실패 시 화면

우리가 앞에서 HelloUserDetailsService를 이용해 인증을 처리할 경우에는 인증 실패 시, Spring Security 내부에서 인증 실패에 대한 전용 Exception인 AuthenticationException을 throw 하게 되고 이 AuthenticationException이 throw 되면 결과적으로 SecurityConfiguration에서 설정한 .failureUrl("/auths/login-form?error") 을 통해 로그인 폼으로 리다이렉트 하면서 아래의 [그림 4-11-2]와 같이 “로그인 인증에 실패했습니다.”라는 인증 실패 메시지를 표시합니다.



[그림 4-11-2] HelloUserDetailsService를 이용해 인증 처리 시, 인증 실패 화면

그런데 Custom AuthenticationProvider를 이용할 경우에는 회원가입 전 인증 실패 시, 왜 [그림 4-11-2]와 같은 화면이 표시되지 않고 [그림 4-11-1]과 같은 “Whitelebel Error Page”가 표시되는 걸까요?

⭐ 이유는 MemberService에서 등록된 회원 정보가 없으면, BusinessLogicException을 throw 하는데 이 BusinessLogicException이 Cusotm AuthenticationProvider를 거쳐 그대로 Spring Security 내부 영역으로 throw 되기 때문입니다.

Spring Security에서는 인증 실패 시, AuthenticationException이 throw 되지 않으면 Exception에 대한 별도의 처리를 하지 않고, 서블릿 컨테이너인 톰캣 쪽으로 이 처리를 넘깁니다.

결국 서블릿 컨테이너 영역에서 해당 Exception에 대해 “/error” URL로 포워딩하는데 우리가 특별히 “/error” URL로 포워딩되었을 때 보여줄 뷰 페이지를 별도로 구성하지 않았기 때문에 디폴트 페이지인 “Whitelebel Error Page”를 브라우저에 표시하는 것입니다.

⭐ 해결책은 간단합니다. Cusotm AuthenticationProvider에서 Exception이 발생할 경우, 이 Exception을 catch 해서 AuthenticationException으로 rethrow를 해주면 됩니다.


개선된 HelloUserAuthenticationProvider(V2)

```java
package com.codestates.auth;

import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Optional;

@Component
public class HelloUserAuthenticationProvider implements AuthenticationProvider {
    private final HelloUserDetailsService userDetailsService;
    private final PasswordEncoder passwordEncoder;

    public HelloUserAuthenticationProvider(HelloUserDetailsService userDetailsService,
                                           PasswordEncoder passwordEncoder) {
        this.userDetailsService = userDetailsService;
        this.passwordEncoder = passwordEncoder;
    }

    // V2: AuthenticationException을 rethrow 하는 개선 코드
    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        UsernamePasswordAuthenticationToken authToken = (UsernamePasswordAuthenticationToken) authentication;

        String username = authToken.getName();
        Optional.ofNullable(username).orElseThrow(() -> new UsernameNotFoundException("Invalid User name or User Password"));
        try {
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            String password = userDetails.getPassword();
            verifyCredentials(authToken.getCredentials(), password);

            Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();
            return UsernamePasswordAuthenticationToken.authenticated(username, password, authorities);
        } catch (Exception ex) {
            throw new UsernameNotFoundException(ex.getMessage()); // (1) AuthenticationException으로 다시 throw 한다.
        }
    }

    @Override
    public boolean supports(Class<?> authentication) {
        return UsernamePasswordAuthenticationToken.class.equals(authentication);
    }

    private void verifyCredentials(Object credentials, String password) {
        if (!passwordEncoder.matches((String)credentials, password)) {
            throw new BadCredentialsException("Invalid User name or User Password");
        }
    }
}
```
코드 4-34에서는 AuthenticationException이 아닌 다른 Exception이 발생할 경우 AuthenticationException으로 다시 rethrow 하도록 개선된 HelloUserAuthenticationProvider 코드입니다.

(1)에서 UsernameNotFoundException을 throw 하도록 수정되었는데, UsernameNotFoundException은 AuthenticationException을 상속하는 하위 Exception이기 때문에 이 UsernameNotFoundException이 throw되면 Spring Security 쪽에서 정상적으로 catch해서 [그림 4-11-2]와 같이 정상적인 인증 실패 화면으로 리다이렉트 시켜줍니다.

⭐ Custom AuthenticationProvider에서 AuthenticationException이 아닌 Exception이 발생할 경우에는 꼭 AuthenticationException을 rethrow 하도록 코드를 구성해야 한다는 사실을 기억하기를 바랍니다.


⭐ AuthenticationProvider
AuthenticationProvider는 Spring Security에서 클라이언트로부터 전달받은 인증 정보를 바탕으로 인증된 사용자인지에 대한 인증 처리를 수행하는 Spring Security 컴포넌트입니다.

AuthenticationProvider는 인터페이스 형태로 정의되어 있으며, Spring Security에서는 AnonymousAuthenticationProvider, DaoAuthenticationProvider, JwtAuthenticationProvider, RememberMeAuthenticationProvider, OAuth2LoginAuthenticationProvider 등 다양한 유형의 AuthenticationProvider 구현체를 제공합니다.



핵심 포인트
Spring Security에서 지원하는 InMemory User는 말 그대로 메모리에 등록되어 사용되는 User이므로 애플리케이션 실행이 종료되면 InMember User 역시 메모리에서 사라진다.

InMemory User를 사용하는 방식은 테스트 환경이나 데모 환경에서 사용할 수 있는 방법이다.

Spring Security는 사용자의 크리덴셜(Credential, 자격증명을 위한 구체적인 수단)을 암호화하기 위한 PasswordEncoder를 제공하며, PasswordEncoder는 다양한 암호화 방식을 제공하며, Spring Security에서 지원하는 PasswordEncoder의 디폴트 암호화 알고리즘은 bcrypt이다.

패스워드 같은 민감한(sensitive) 정보는 반드시 암호화되어 저장되어야 합니다.
패스워드는 복호화할 이유가 없으므로 단방향 암호화 방식으로 암호화되어야 한다.

Spring Security에서 SimpleGrantedAuthority를 사용해 Role 베이스 형태의 권한을 지정할 때 ‘ROLE_’ + 권한명 형태로 지정해 주어야 한다.

Spring Security에서는 Spring Security에서 관리하는 User 정보를 UserDetails로 관리한다.

UserDetails는 UserDetailsService에 의해 로드(load)되는 핵심 User 정보를 표현하는 인터페이스입니다.

UserDetailsService는 User 정보를 로드(load)하는 핵심 인터페이스이다.

일반적으로 Spring Security에서는 인증을 시도하는 주체를 User(비슷한 의미로 Principal도 있음)라고 부른다. Principal은 User의 더 구체적인 정보를 의미하며, 일반적으로 Username을 의미한다.

Custom UserDetailsService를 사용해 로그인 인증을 처리하는 방식은 Spring Security가 내부적으로 인증을 대신 처리해 주는 방식이다.

AuthenticationProvider는 Spring Security에서 클라이언트로부터 전달받은 인증 정보를 바탕으로 인증된 사용자인지를 처리하는 Spring Security의 컴포넌트이다.



심화 학습
Spring Security에서 제공하는 PasswordEncoder에서 더 알아보고 싶다면 아래 링크를 참고하세요.

https://docs.spring.io/spring-security/reference/features/authentication/password-storage.html#authentication-password-storage
bcrypt 알고리즘에 대해서 더 알아보고 싶다면 아래 링크를 참고하세요.

https://ko.wikipedia.org/wiki/Bcrypt
단방향 암호화에 대해서 더 알아보고 싶다면 아래 링크를 참고하세요.

https://en.citizendium.org/wiki/One-way_encryption
Clickjacking 공격에 대해서 더 알아보고 싶다면 아래 링크를 참고하세요.

https://en.wikipedia.org/wiki/Clickjacking

https://ko.wikipedia.org/wiki/클릭재킹



 ##################################