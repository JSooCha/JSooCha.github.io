---
title: Linked List
excerpt: 자료구조의 이해
categories: Java
tags: [codestates, Java]
toc: true
toc_sticky: true
author_profile: true
sidebar_main: true
published : true
---

## 연결 리스트 : Linked List
- 실제 메모리 공간에서 서로 떨어져 있는 데이터를 링크(포인터)로 연결시켜 리스트 형태로 구현한 자료구조

<br>

### 구조
- 배열(Array)
  - 연속된 메모리 공간을 차지하고, 인덱스로 각 요소의 데이터 사용 가능
  - 연속된 메모리 주소값 안에 데이터를 넣는 구조로, 위치를 바꾸려면 데이터가 이동해야 함
- Linked list 
  - 노드가 서로 흩어져 있으며, 각 노드가 데이터와 다음 데이터의 주소를 가지고 선형으로 연결
    - 연속된 메모리 주소가 아니므로, 주소를 통해 다음 노드에 접근 가능
    - 마지막 노드는 가리킬 곳이 없으므로, 새로 추가되기 전까지 null을 가리킴

<br>

### 특징
#### 노드 추가/삭제가 쉬움
  - 배열 : 메모리 순서가 정해져 있어, 값 추가/삭제 시 메모리에 재할당 필요
  - Linked List : 순서가 지정되지 않아, 데이터를 담은 노드를 어디서든 손쉽게 추가/삭제 가능

배열은 추가하거나 삭제하는 경우 때에 따라 시간 복잡도가 많이 걸립니다. 배열의 예를 먼저 살펴봅시다.

<br>

##### 배열의 추가
마지막 요소의 수정은 빠르나, 맨 앞의 요소 수정은 가장 오래 걸림

1. 마지막 인덱스를 새로 만듦 
2. 삽입하고자 하는 인덱스까지 모든 데이터를 한 칸씩 이동
3. 원하는 인덱스에 값 추가

- 마지막 인덱스에 데이터 추가
  - 가장 빠른 시간복잡도 
    - O(1)
- 0번 인덱스에 데이터 추가
  - 모든 데이터를 오른쪽으로 옮겨야 함
    - O(n)
- 삭제는 반대 과정으로 동작 

<br>

##### Linked List의 추가
어디서나 노드를 추가/삭제해도 O(1)의 빠른 시간 복잡도를 가짐

- 다음 노드를 가리키는 메모리 주소만 변경하면 쉽게 추가 가능
  - 이전 노드는 추가한 노드를 가리키고, 추가한 노드는 이전 노드가 가리키고 있던 노드를 가리키면 됨
- 삭제는 반대 과정으로 동작
  - 삭제할 노드는 null을 가리키고, 삭제할 노드를 가리키고 있던 노드는 삭제할 노드가 가리키던 노드를 가리킴

<br>

####  노드의 값을 찾으려면 최대 전체를 순회해야 함
- 배열 : 연속적으로 이어져 있어, 주소로 쉽게 접근 가능 
  - 인덱스에 관계없이, O(1)의 시간복잡도
- Linked List : 서로 흩어져 있어, 특정 노드에 쉽게 접근 불가
  - 순회 전까지 head node와 다음 노드의 주소, 리스트의 사이즈에 대한 정보만 알고 있음
    - head node : 첫 번째 노드
    - 값 접근 시, head node에서 출발하여 해당 노드까지 차례대로 순회해야 함
  - head node의 값은 O(1)의 시간 복잡도, 마지막 노드까지의 순회를 고려하면 최대 O(n)의 시간 복잡도를 가짐

<br>

### 실사용 예제
- 삽입과 삭제가 중요한 곳에 활용
  - join, split 메서드처럼 데이터 삽입/삭제가 중요한 메서드의 구현에도 활용 가능
- 동적 기억장소 관리 (dynamic storage management)
  - 실행되는 작업에 필요한 크기만큼의 메모리를 할당하는 방법에 활용
- Garbage collection
  - 참조자료형의 데이터 타입을 관리하는 알고리즘 중 하나
- Advanced : 해시테이블의 충돌 시 해결법 중 chaning 방법을 사용할 때, Linked list 활용
