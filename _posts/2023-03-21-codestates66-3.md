---
title: JWT를 이용한 자격 증명 및 검증 구현
excerpt: 로그인 인증에 성공한 사용자에게 JWT 생성 및 발급
categories: Spring
tags: [codestates, Spring]
toc: true
toc_sticky: true
author_profile: true
sidebar_main: true
published : true
---
JWT를 이용한 자격 증명 및 검증 구현
이전 챕터에서 회원 가입 시 등록한 이메일 주소와 패스워드를 이용해 로그인 인증을 성공적으로 수행하면 response header(Authorization, Refresh)를 통해 JWT를 전달받을 수 있었습니다.


이번 시간에는 클라이언트 측에서 JWT를 이용해 자격 증명이 필요한 리소스에 대한 request 전송 시, request header를 통해 전달받은 JWT를 서버 측에서 검증하는 기능을 구현해 보겠습니다.



JWT 검증 기능 구현
1️⃣ JWT 검증 필터 구현
JWT 검증을 위해 가장 먼저 해야 할 작업은 JWT를 검증하는 전용 Security Filter를 구현하는 것입니다.


JwtVerificationFilter

```java
package com.codestates.auth.filter;

import com.codestates.auth.jwt.JwtTokenizer;
import com.codestates.auth.utils.CustomAuthorityUtils;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import java.util.Map;

public class JwtVerificationFilter extends OncePerRequestFilter {  // (1)
    private final JwtTokenizer jwtTokenizer;
    private final CustomAuthorityUtils authorityUtils;

    // (2)
    public JwtVerificationFilter(JwtTokenizer jwtTokenizer,
                                 CustomAuthorityUtils authorityUtils) {
        this.jwtTokenizer = jwtTokenizer;
        this.authorityUtils = authorityUtils;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        Map<String, Object> claims = verifyJws(request); // (3)
        setAuthenticationToContext(claims);      // (4)

        filterChain.doFilter(request, response); // (5)
    }

    // (6)
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
        String authorization = request.getHeader("Authorization");  // (6-1)

        return authorization == null || !authorization.startsWith("Bearer");  // (6-2)
    }

    private Map<String, Object> verifyJws(HttpServletRequest request) {
        String jws = request.getHeader("Authorization").replace("Bearer ", ""); // (3-1)
        String base64EncodedSecretKey = jwtTokenizer.encodeBase64SecretKey(jwtTokenizer.getSecretKey()); // (3-2)
        Map<String, Object> claims = jwtTokenizer.getClaims(jws, base64EncodedSecretKey).getBody();   // (3-3)

        return claims;
    }

    private void setAuthenticationToContext(Map<String, Object> claims) {
        String username = (String) claims.get("username");   // (4-1)
        List<GrantedAuthority> authorities = authorityUtils.createAuthorities((List)claims.get("roles"));  // (4-2)
        Authentication authentication = new UsernamePasswordAuthenticationToken(username, null, authorities);  // (4-3)
        SecurityContextHolder.getContext().setAuthentication(authentication); // (4-4)
    }
}
```
[코드 4-84] JWT 검증을 위한 JwtVerificationFilter


코드 4-84는 클라이언트 측에서 전송된 request header에 포함된 JWT에 대해 검증 작업을 수행하는 JwtVerificationFilter의 코드입니다.


코드의 설명은 다음과 같습니다.

Spring Security에서는 (1)과 같이 OncePerRequestFilter를 확장해서 request 당 한 번만 실행되는 Security Filter를 구현할 수 있습니다.

JWT의 검증은 request 당 단 한 번만 수행하면 되기 때문에 JWT 전용 Filter로 만들기에는 OncePerRequestFilter를 이용하는 것이 적절하다고 볼 수 있습니다.

💡 인증과 관련된 Filter는 성공이냐 실패냐를 단 한 번만 판단하면 됩니다. 성공도 아니고 실패도 아닌 어중간한 결과는 존재하지 않으며 여러 번 판단할 필요도 없는 것입니다.


(2)와 같이 JwtTokenizer와 CustomAuthorityUtils를 DI 받습니다.

JwtTokenizer는 JWT를 검증하고 Claims(토큰에 포함된 정보)를 얻는 데 사용됩니다.

CustomAuthorityUtils는 JWT 검증에 성공하면 Authentication 객체에 채울 사용자의 권한을 생성하는 데 사용됩니다.


(3)의 verifyJws() 메서드는 JWT를 검증하는 데 사용되는 private 메서드입니다.

(3-1)에서는 request의 header에서 JWT를 얻고 있습니다.

이전 챕터에서 클라이언트의 로그인 인증이 성공적으로 수행되면, 서버 측에서 Authorization header에 JWT를 추가했던 로직을 떠올려 보기 바랍니다.

💡 이전 챕터에서 Authorization header에 추가된 JWT는 response header에 포함된 것이고, (3-1)에서의 JWT는 클라이언트가 response header로 전달받은 JWT를 request header에 추가해서 서버 측에 전송한 것이라는 사실을 잊지 마세요!

그리고 String 클래스의 replace() 메서드를 이용해 “Bearer “부분을 제거합니다.

💡 (3-1)에서 변수명을 jws로 지정한 이유는 서명된 JWT를 JWS(JSON Web Token Signed)라고 부르기 때문이라는 점 참고하세요.

(3-2)에서는 JWT 서명(Signature)을 검증하기 위한 Secret Key를 얻습니다.

(3-3)에서는 JWT에서 Claims를 파싱 합니다.

여기서 기억해야 할 부분은 JWT에서 Claims를 파싱 할 수 있다는 의미는 내부적으로 서명(Signature) 검증에 성공했다는 의미입니다.

⭐ 즉, verify() 같은 검증 메서드가 따로 존재하는 것이 아니라 Claims가 정상적으로 파싱이 되면 서명 검증 역시 자연스럽게 성공했다는 사실을 꼭 기억하기 바랍니다.


(4)의 setAuthenticationToContext() 메서드는 Authentication 객체를 SecurityContext에 저장하기 위한 private 메서드입니다.

(4-1)에서는 JWT에서 파싱 한 Claims에서 username을 얻습니다.

(4-2)에서는 JWT의 Claims에서 얻은 권한 정보를 기반으로 List<GrantedAuthority를 생성합니다.

(4-3)에서는 username과 List<GrantedAuthority를 포함한 Authentication 객체를 생성합니다.

(4-4)에서는 SecurityContext에 Authentication 객체를 저장합니다.


⭐ JWT는 클라이언트 정보 등의 상태를 저장하지 않는 Stateless한 방식인데 SecurityContext에 Authentication을 저장하게 되면 세션의 상태는 어떻게 되는지 궁금해할 수도 있습니다.

SecurityContext에 Authentication을 저장하게 되면 Spring Security의 세션 정책(Session Policy)에 따라서 세션을 생성할 수도 있고, 그렇지 않을 수도 있습니다.

JWT 환경에서는 세션 정책(Session Policy) 설정을 통해 세션 자체를 생성하지 않도록 설정합니다.

세션 정책(Session Policy)에 대해서는 이어서 바로 확인해 보겠습니다.


문제없이 JWT의 서명 검증에 성공하고, Security Context에 Authentication을 저장한 뒤에는 (5)와 같이 다음(Next) Security Filter를 호출합니다.

(6)은 OncePerRequestFilter의 shouldNotFilter()를 오버라이드 한 것으로, 특정 조건에 부합하면(true이면) 해당 Filter의 동작을 수행하지 않고 다음 Filter로 건너뛰도록 해줍니다.

(6-1)에서 Authorization header의 값을 얻은 후에

(6-2)에서는 Authorization header의 값이 null이거나 Authorization header의 값이 “Bearer”로 시작하지 않는다면 해당 Filter의 동작을 수행하지 않도록 정의합니다.

⭐ 이 말의 의미는 JWT가 Authorization header에 포함되지 않았다면 JWT 자격증명이 필요하지 않은 리소스에 대한 요청이라고 판단하고 다음(Next) Filter로 처리를 넘기는 것입니다.

⭐ 만일 JWT 자격 증명이 필요한 리소스 요청인데 실수로 JWT를 포함하지 않았다 하더라도 이 경우에는 Authentication이 정상적으로 SecurityContext에 저장되지 않은 상태이기 때문에 다른 Security Filter를 거쳐 결국 Exception을 던지게 될 것입니다.



2️⃣ SecurityConfiguration 설정 업데이트
JwtVerificationFilter를 사용하기 위해서는 아래와 같은 두 가지 설정을 SecurityConfigruation에 추가해야 합니다.

세션 정책 설정 추가

JwtVerificationFilter 추가


JwtVerificationFilter에서 JWT의 자격 검증에 성공하게 되면 인증된 Authentication 객체를 SecurityContext에 저장합니다. (코드 4-84의 (4)를 참고해 주세요)

그런데 앞에서 언급한 것처럼 stateless한 애플리케이션을 유지하기 위해 세션 유지 시간을 아주 짧게 가져가기 위한(거의 무상태) 설정을 SecurityConfigruation에 추가할 필요가 있습니다.


그리고 추가적으로 JwtVerificationFilter를 Security Filter Chain에 추가해 보겠습니다.


SecurityConfiguration(V4)

```java
package com.codestates.config;

import com.codestates.auth.filter.JwtAuthenticationFilter;
import com.codestates.auth.filter.JwtVerificationFilter;
import com.codestates.auth.handler.MemberAuthenticationFailureHandler;
import com.codestates.auth.handler.MemberAuthenticationSuccessHandler;
import com.codestates.auth.jwt.JwtTokenizer;
import com.codestates.auth.utils.CustomAuthorityUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

import static org.springframework.security.config.Customizer.withDefaults;

/**
 * SessionCreationPolicy 설정 추가
 */
@Configuration
public class SecurityConfiguration {
    private final JwtTokenizer jwtTokenizer;
    private final CustomAuthorityUtils authorityUtils; // 추가

    public SecurityConfigurationV6(JwtTokenizer jwtTokenizer,
                                   CustomAuthorityUtils authorityUtils) {
        this.jwtTokenizer = jwtTokenizer;
        this.authorityUtils = authorityUtils;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .headers().frameOptions().sameOrigin()
            .and()
            .csrf().disable()
            .cors(withDefaults())
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  // (1) 추가
            .and()
            .formLogin().disable()
            .httpBasic().disable()
            .apply(new CustomFilterConfigurer())
            .and()
            .authorizeHttpRequests(authorize -> authorize
                    .anyRequest().permitAll()
            );
        return http.build();
    }

    ...
    ...

    public class CustomFilterConfigurer extends AbstractHttpConfigurer<CustomFilterConfigurer, HttpSecurity> {
        @Override
        public void configure(HttpSecurity builder) throws Exception {
            AuthenticationManager authenticationManager = builder.getSharedObject(AuthenticationManager.class);

            JwtAuthenticationFilter jwtAuthenticationFilter = new JwtAuthenticationFilter(authenticationManager, jwtTokenizer);
            jwtAuthenticationFilter.setFilterProcessesUrl("/v11/auth/login");
            jwtAuthenticationFilter.setAuthenticationSuccessHandler(new MemberAuthenticationSuccessHandler());
            jwtAuthenticationFilter.setAuthenticationFailureHandler(new MemberAuthenticationFailureHandler());

            JwtVerificationFilter jwtVerificationFilter = new JwtVerificationFilter(jwtTokenizer, authorityUtils);  // (2) 추가

            builder
                .addFilter(jwtAuthenticationFilter)
                .addFilterAfter(jwtVerificationFilter, JwtAuthenticationFilter.class);   // (3)추가
        }
    }
}
```
[코드 4-85] JWT 검증을 위한 설정 추가(V4)


코드 4-85는 JWT 검증을 위한 추가 설정이 포함된 SecurityConfiguration의 코드 일부입니다.


코드의 설명은 다음과 같습니다.

(1)의 .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)를 통해서 세션을 생성하지 않도록 설정합니다.

SessionCreationPolicy의 설정값으로는 아래와 같이 총 네 개의 값을 사용할 수 있습니다.

SessionCreationPolicy.*ALWAYS*

항상 세션을 생성합니다.
SessionCreationPolicy.NEVER

세션을 생성하지 않지만 만약에 이미 생성된 세션이 있다면 사용합니다.
SessionCreationPolicy.*IF_REQUIRED*

필요한 경우에만 세션을 생성합니다.
SessionCreationPolicy.*STATELESS*

세션을 생성하지 않으며, SecurityContext 정보를 얻기 위해 결코 세션을 사용하지 않습니다.
(2)에서는 JwtVerificationFilter의 인스턴스를 생성하면서 JwtVerificationFilter에서 사용되는 객체들을 생성자로 DI 해줍니다.

(3)에서는 JwtVerificationFilter를 JwtAuthenticationFilter 뒤에 추가합니다.

JwtVerificationFilter는 JwtAuthenticationFilter에서 로그인 인증에 성공한 후 발급받은 JWT가 클라이언트의 request header(Authorization 헤더)에 포함되어 있을 경우에만 동작합니다.



서버 측 리소스에 역할(Role) 기반 권한 적용
로그인 인증 후, JWT도 무사히 잘 발급되고 발급된 JWT를 이용해서 클라이언트의 자격 증명에 대한 검증까지 잘 되는 걸 확인했습니다.

그런데 Spring Security 쪽에서 서버 측 리소스에 적절한 접근 권한 설정을 하지 않는다면 아무리 JWT를 사용하여 클라이언트의 자격 증명이 확인된다 하더라도 그 의미가 퇴색됩니다.

JWT를 이용한 자격 증명이라는 의미에는 특정 리소스에 접근할 수 있는 적절한 권한을 가졌는지를 판단해야 한다는 의미도 포함하고 있으니까요.


현재까지의 SecurityConfiguration에는 아래의 코드 4-86과 같이 사용자의 권한 여부에 상관없이 클라이언트 측에서 애플리케이션의 모든 리소스에 접근할 수 있도록 설정된 상태입니다.


접근 권한 설정이 되어 있지 않은 SecurityConfiguration(V4)

```java
package com.codestates.config;

import com.codestates.auth.filter.JwtAuthenticationFilter;
import com.codestates.auth.handler.MemberAuthenticationFailureHandler;
import com.codestates.auth.handler.MemberAuthenticationSuccessHandler;
import com.codestates.auth.jwt.JwtTokenizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
public class SecurityConfiguration {
    ...
    ...

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .headers().frameOptions().sameOrigin()
            .and()
            .csrf().disable()
            .cors(withDefaults())
            .formLogin().disable()
            .httpBasic().disable()
            .apply(new CustomFilterConfigurer())
            .and()
            .authorizeHttpRequests(authorize -> authorize
                    .anyRequest().permitAll()               // (1)
            );
        return http.build();
    }
    
    ...
    ...
}
```
[코드 4-86] 접근 권한 여부와 상관없이 모든 리소스에 대한 접근이 허용된 상태


코드 4-86을 보면 (1)과 같이 .anyRequest().permitAll()를 통해 서버 측으로 들어오는 모든 request에 대해서 접근을 허용하고 있습니다.


이제 우리가 여태까지 구현해 본 커피 주문 샘플 애플리케이션의 리소스 중에서 MemberController를 통해 접근할 수 있는 리소스에 대한 접근 권한을 부여해 보도록 하겠습니다.


수정된 SecurityConfiguration(V5)

```java
package com.codestates.config;

import com.codestates.auth.filter.JwtAuthenticationFilter;
import com.codestates.auth.filter.JwtVerificationFilter;
import com.codestates.auth.handler.MemberAccessDeniedHandler;
import com.codestates.auth.handler.MemberAuthenticationEntryPoint;
import com.codestates.auth.handler.MemberAuthenticationFailureHandler;
import com.codestates.auth.handler.MemberAuthenticationSuccessHandler;
import com.codestates.auth.jwt.JwtTokenizer;
import com.codestates.auth.utils.CustomAuthorityUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.AuthenticationFailureHandler;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
public class SecurityConfiguration {
    ...
    ...

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .headers().frameOptions().sameOrigin()
            .and()
            .csrf().disable()
            .cors(withDefaults())
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .formLogin().disable()
            .httpBasic().disable()
            .apply(new CustomFilterConfigurer())
            .and()
            .authorizeHttpRequests(authorize -> authorize
                    .antMatchers(HttpMethod.POST, "/*/members").permitAll()         // (1) 추가
                    .antMatchers(HttpMethod.PATCH, "/*/members/**").hasRole("USER")  // (2) 추가
                    .antMatchers(HttpMethod.GET, "/*/members").hasRole("ADMIN")     // (3) 추가
                    .antMatchers(HttpMethod.GET, "/*/members/**").hasAnyRole("USER", "ADMIN")  // (4) 추가
                    .antMatchers(HttpMethod.DELETE, "/*/members/**").hasRole("USER")  // (5) 추가
                    .anyRequest().permitAll()
            );
        return http.build();
    }
    
    ...
    ...
}
```
[코드 4-87] MemberController에 대한 역할(Role) 기반의 접근 권한을 부여


코드 4-87은 MemberController를 통해 접근할 수 있는 리소스에 대해 접근 권한을 부여한 SecurityConfiguration 코드의 일부입니다.


코드에 대한 설명은 다음과 같습니다.

회원 등록의 경우, 접근 권한 여부와 상관없이 누구나 접근이 가능해야 하므로 (1)과 같이 회원등록에 사용되는 URL(”/v11/members”)과 HTTP Method(여기서는 POST)에 해당된다면 접근을 허용합니다.

여러분들이 MemberController의 postMember() 핸들러 메서드의 URL과 HTTP Method를 확인해 본다면 (1)에서 설정한 조건이 이해가 되리라 생각합니다.


회원 정보 수정의 경우, (2)와 같이 일반 사용자(USER) 권한만 가진 사용자만 접근이 가능하도록 허용합니다.

회원 정보 수정 요청을 처리하는 MemberController의 patchMember() 핸들러 메서드에 대한 접근 권한 부여 설정이라는 사실을 기억하세요.

.antMatchers(HttpMethod.PATCH, "/*/members/**")에서 ‘**’는 하위 URL로 어떤 URL이 오더라도 매치가 된다는 의미입니다.


모든 회원 정보의 목록은 (3)과 같이 관리자(ADMIN) 권한을 가진 사용자만 접근이 가능하여야 할 것입니다.

회원 정보 목록 조회 요청을 처리하는 MemberController의 getMembers() 핸들러 메서드에 대한 접근 권한 부여 설정에 해당합니다.


특정 회원에 대한 정보 조회는 (4)와 같이 일반 사용자(USER)와 관리자(ADMIN) 권한을 가진 사용자 모두 접근이 가능하면 될 것 같군요.

특정 회원 정보 조회 요청을 처리하는 MemberController의 getMember() 핸들러 메서드에 대한 접근 권한 부여 설정에 해당합니다.


특정 회원을 삭제하는 요청은 (5)와 같이 해당 사용자가 탈퇴 같은 처리를 할 수 있어야 하므로 일반 사용자(USER) 권한만 가진 사용자만 접근이 가능하도록 허용합니다.

특정 회원 정보 삭제 요청을 처리하는 MemberController의 deleteMember() 핸들러 메서드에 대한 접근 권한 부여 설정에 해당합니다.


✅ 셀프 미니 실습

코드 4-87에서는 MemberController를 통해 접근할 수 있는 리소스에 대해 접근 권한만 부여된 채로 나머지 리소스에 대한 요청은 모드 접근이 가능한 상태입니다.

그런데 우리가 지금껏 구현한 커피 주문 샘플 애플리케이션에는 다른 리소스가 더 있다는 사실을 여러분들도 알고 있을 거라 생각합니다. ^^

CoffeeController와 OrderController를 통해 접근할 수 있는 리소스에 대한 접근 권한은 여러분들이 직접 한번 추가해 볼 수 있도록 셀프 미니 실습으로 남겨 두도록 하겠습니다. ^^



JWT 검증 테스트
이제 JWT를 사용한 자격 검증이 정상적으로 잘 이루어지는지 간단하게 테스트해 보도록 하겠습니다.

애플리케이션 실행 후, 아래와 같은 조건으로 테스트를 수행해 보겠습니다.


1️⃣ JWT를 Authorization header에 포함하지 않을 경우


[그림 4-24] JWT를 Authorization header에 포함하지 않은 경우


[그림 4-24]는 JWT를 Authorization header에 포함하지 않은 채 MemberController의 getMember() 핸들러 메서드에 request를 전송한 모습입니다.


response 결과를 보면 Spring Security에서 403 status를 전달한 것을 볼 수 있습니다.

JWT가 Authorization header에 포함되지 않으면 JwtVerificationFilter를 건너뛰게 되고, 나머지 Security Filter에서 권한 체크를 하면서 적절한 권한이 부여되지 않았기 때문에 403 status가 전달됩니다.



2️⃣ 유효하지 않은 JWT를 Authorization header에 포함할 경우


[그림 4-25] 유효하지 않은 JWT를 Authorization header에 포함할 경우


이번에는 [그림 4-25]와 같이 유효하지 않은 JWT를 Authorization header에 포함하여 MemberController의 getMember() 핸들러 메서드에 request를 전송한 모습입니다.


역시 Spring Security에서 403 status를 전달한 것을 볼 수 있습니다.


유효하지 않은 JWT의 경우 접근 권한에 대한 에러를 나타내는 403 status보다는 JWT의 검증에 실패했기 때문에 자격 증명에 실패한 것과 같으므로 UNAUTHORIZED를 의미하는 401 status가 더 적절할 것 같습니다.

이 부분은 이어지는 예외 처리 부분에서 설명하겠습니다.



3️⃣ 권한이 부여되지 않은 리소스에 request를 전송할 경우


[그림 4-26] 권한이 부여되지 않은 리소스에 request를 전송할 경우


[그림 4-26]에서는 USER 권한만 부여된 사용자의 JWT를 Authorization header에 추가하고, ADMIN 권한에만 접근이 허용된 MemberController의 getMembers() 핸들러 메서드에 request를 전송할 때의 결과입니다.


JwtVerificationFilter에서 JWT의 자격 증명은 정상적으로 수행되었지만 ADMIN 권한이 없는 사용자이므로 403 status가 전달됩니다.



예외 처리
자, 이제 JWT를 사용하는 자격 검증에 대한 구현은 끝난 걸까요? ^^

이 상태에서 마무리하더라도 보안적으로 크게 문제 될 건 없습니다.

하지만 조금 더 깔끔한 마무리를 위해서 예외 처리와 관련된 로직을 추가해 보도록 하겠습니다.



1️⃣ JwtVerificationFilter에 예외 처리 로직 추가
JwtVerificationFilter의 경우, 클라이언트로부터 전달받은 JWT의 Claims를 얻는 과정에서 내부적으로 JWT에 대한 서명(Signature)을 검증합니다.

그런데 현재 JwtVerificationFilter에서는 JWT에 대한 서명(Signature) 검증에 실패할 경우 throw되는 SignatureException에 대해서 어떤 처리도 하지 않고 있습니다.

그리고 JWT가 만료될 경우, 발생하는 ExpiredJwtException에 대한 처리도 이루어지지 않았습니다.


JWT 검증 과정에서 발생할 수 있는 Exception을 처리할 수 있는 예외 처리 로직을 JwtVerificationFilter에 추가해 보도록 하겠습니다.

```java
package com.codestates.auth.filter;

import com.codestates.auth.jwt.JwtTokenizer;
import com.codestates.auth.utils.CustomAuthorityUtils;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.security.SignatureException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import java.util.Map;

public class JwtVerificationFilter extends OncePerRequestFilter {
    ...
    ...

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // (1)
        try {
            Map<String, Object> claims = verifyJws(request);
            setAuthenticationToContext(claims);
        } catch (SignatureException se) {
            request.setAttribute("exception", se);
        } catch (ExpiredJwtException ee) {
            request.setAttribute("exception", ee);
        } catch (Exception e) {
            request.setAttribute("exception", e);
        }

        filterChain.doFilter(request, response);
    }
    
    ...
    ...
}
```
[코드 4-88] 예외 처리 로직이 추가된 JwtVerificationFilter


코드 4-88에서는 JwtVerificationFilter의 doFilterInternal() 메서드에 예외 처리 로직이 추가되었습니다.


예외 처리 로직은 간단합니다.

(1)과 같이 try~catch 문으로 특정 예외 타입의 Exception이 catch 되면 해당 Exception을 request.setAttribute("exception", Exception 객체)와 같이 HttpServletRequest의 애트리뷰트(Attribute)로 추가됩니다.


이렇게 추가된 애트리뷰트는 바로 아래에서 설명하는 AuthenticationEntryPoint에서 사용할 수 있습니다.

💡JwtVerificationFilter 예외 처리의 키포인트는 우리가 일반적으로 알고 있는 예외 처리 방식과는 다르게 Exception을 catch한 후에 Exception을 다시 throw 한다든지 하는 처리를 하지 않고, 단순히 request.setAttribute()를 설정하는 일밖에 하지 않는다는 것입니다.


이런 식으로 예외 처리를 하게 되면 어떻게 될까요?

예외가 발생하게 되면 SecurityContext에 클라이언트의 인증 정보(Authentication 객체)가 저장되지 않습니다.


⭐ SecurityContext에 클라이언트의 인증 정보(Authentication 객체)가 저장되지 않은 상태로 다음(next) Security Filter 로직을 수행하다 보면 결국에는 Filter 내부에서 AuthenticationException이 발생하게 되고, 이 AuthenticationException은 바로 아래에서 설명하는 AuthenticationEntryPoint가 처리하게 됩니다.


⭐ SecurityContext에 클라이언트의 인증 정보가 채워지지 않은 상태에서 Security Filter 로직을 수행하게 되면 Security Filter 체인의 Filter 내부에서 AuthenticationException이 발생한다는 사실을 꼭 기억하세요!



2️⃣ AuthenticationEntryPoint 구현
AuthenticationEntryPoint는 SignatureException, ExpiredJwtException 등 Exception 발생으로 인해 SecurityContext에 Authentication이 저장되지 않을 경우 등 AuthenticationException이 발생할 때 호출되는 핸들러 같은 역할을 합니다.


MemberAuthenticationEntryPoint

```java
package com.codestates.auth.handler;

import com.codestates.auth.utils.ErrorResponder;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Slf4j
@Component
public class MemberAuthenticationEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        Exception exception = (Exception) request.getAttribute("exception");
        ErrorResponder.sendErrorResponse(response, HttpStatus.UNAUTHORIZED);

        logExceptionMessage(authException, exception);
    }

    private void logExceptionMessage(AuthenticationException authException, Exception exception) {
        String message = exception != null ? exception.getMessage() : authException.getMessage();
        log.warn("Unauthorized error happened: {}", message);
    }
}
```
[코드 4-89] AuthenticationEntryPoint를 구현한 MemberAuthenticationEntryPoint


코드 4-89는 AuthenticationEntryPoint를 구현한 MemberAuthenticationEntryPoint입니다.


MemberAuthenticationEntryPoint 클래스는 인증 과정에서 AuthenticationException 이 발생할 경우 호출되며, 처리하고자 하는 로직을 commence() 메서드에 구현하면 됩니다.

코드 4-89에서는 인증 과정에서 AuthenticationException 발생하면 ErrorResponse를 생성해서 클라이언트에게 전송합니다.


ErrorResponder

```java
package com.codestates.auth.utils;

import com.codestates.response.ErrorResponse;
import com.google.gson.Gson;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class ErrorResponder {
    public static void sendErrorResponse(HttpServletResponse response, HttpStatus status) throws IOException {
        Gson gson = new Gson();
        ErrorResponse errorResponse = ErrorResponse.of(status);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(status.value());
        response.getWriter().write(gson.toJson(errorResponse, ErrorResponse.class));
    }
}
```
[코드 4-90] ErrorResponse를 클라이언트에게 전송하기 위한 ErrorResponder 클래스


ErrorResponder 클래스는 ErrorResponse를 출력 스트림으로 생성하는 역할을 합니다.



3️⃣ AccessDeniedHandler 구현
AccessDeniedHandler는 인증에는 성공했지만 해당 리소스에 대한 권한이 없으면 호출되는 핸들러입니다.

```java
package com.codestates.auth.handler;

import com.codestates.auth.utils.ErrorResponder;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Slf4j
@Component
public class MemberAccessDeniedHandler implements AccessDeniedHandler {
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        ErrorResponder.sendErrorResponse(response, HttpStatus.FORBIDDEN);
        log.warn("Forbidden error happened: {}", accessDeniedException.getMessage());
    }
}
```
[코드 4-91] AccessDeniedHandler를 구현한 MemberAccessDeniedHandler


코드 4-91은 AccessDeniedHandler를 구현한 MemberAccessDeniedHandler입니다.

MemberAccessDeniedHandler클래스는 요청한 리소스에 대해 적절한 권한이 없으면 호출되는 핸들러로서, 처리하고자 하는 로직을 handle() 메서드에 구현하면 됩니다.

코드 4-91에서는 적절한 권한인지 확인하는 과정에서 AccessDeniedException이 발생하면 ErrorResponse를 생성해서 클라이언트에게 전송합니다.



4️⃣ SecurityConfiguration에 AuthenticationEntryPoint 및 AccessDeniedHandler 추가
앞에서 구현한 MemberAuthenticationEntryPoint와 MemberAccessDeniedHandler를 사용할 수 있도록 SecurityConfiguration에 추가해 보겠습니다.



SecurityConfiguration(V6)

```java
package com.codestates.config;

import com.codestates.auth.filter.JwtAuthenticationFilter;
import com.codestates.auth.filter.JwtVerificationFilter;
import com.codestates.auth.handler.MemberAccessDeniedHandler;
import com.codestates.auth.handler.MemberAuthenticationEntryPoint;
import com.codestates.auth.handler.MemberAuthenticationFailureHandler;
import com.codestates.auth.handler.MemberAuthenticationSuccessHandler;
import com.codestates.auth.jwt.JwtTokenizer;
import com.codestates.auth.utils.CustomAuthorityUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

import static org.springframework.security.config.Customizer.withDefaults;

/**
 * authenticationEntryPoint와 accessDeniedHandler 추가
 */
@Configuration
public class SecurityConfiguration {
   ...
   ...

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .headers().frameOptions().sameOrigin()
            .and()
            .csrf().disable()
            .cors(withDefaults())
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .formLogin().disable()
            .httpBasic().disable()
            .exceptionHandling()
            .authenticationEntryPoint(new MemberAuthenticationEntryPoint())  // (1) 추가
            .accessDeniedHandler(new MemberAccessDeniedHandler())            // (2) 추가
            .and()
            .apply(new CustomFilterConfigurer())
            .and()
            .authorizeHttpRequests(authorize -> authorize
                    .antMatchers(HttpMethod.POST, "/*/members").permitAll()
                    .antMatchers(HttpMethod.PATCH, "/*/members/**").hasRole("USER")
                    .antMatchers(HttpMethod.GET, "/*/members").hasRole("ADMIN")
                    .antMatchers(HttpMethod.GET, "/*/members/**").hasAnyRole("USER", "ADMIN")
                    .antMatchers(HttpMethod.DELETE, "/*/members/**").hasRole("USER")
                    .anyRequest().permitAll()
            );
        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }

    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("*"));
        configuration.setAllowedMethods(Arrays.asList("GET","POST", "PATCH", "DELETE"));
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("\/**", configuration);         // 주의 사항: 콘텐츠 표시 오류로 인해 '/**'를 '\/**'로 표기했으니 실제 코드 구현 시에는 '\(역슬래시)'를 빼 주세요.
        return source;
    }

    public class CustomFilterConfigurer extends AbstractHttpConfigurer<CustomFilterConfigurer, HttpSecurity> {
        @Override
        public void configure(HttpSecurity builder) throws Exception {
            AuthenticationManager authenticationManager = builder.getSharedObject(AuthenticationManager.class);

            JwtAuthenticationFilter jwtAuthenticationFilter = new JwtAuthenticationFilter(authenticationManager, jwtTokenizer);
            jwtAuthenticationFilter.setFilterProcessesUrl("/v11/auth/login");
            jwtAuthenticationFilter.setAuthenticationSuccessHandler(new MemberAuthenticationSuccessHandler());
            jwtAuthenticationFilter.setAuthenticationFailureHandler(new MemberAuthenticationFailureHandler());

            JwtVerificationFilter jwtVerificationFilter = new JwtVerificationFilter(jwtTokenizer, authorityUtils);

            builder
                .addFilter(jwtAuthenticationFilter)
                .addFilterAfter(jwtVerificationFilter, JwtAuthenticationFilter.class);
        }
    }
}
```
[코드 4-92] AuthenticationEntryPoint 및 AccessDeniedHandler 추가한 SecurityConfiguration


코드 4-92의 SecurityConfiguration에서는 (1), (2)와 같이 MemberAuthenticationEntryPoint와 MemberAccessDeniedHandler가 추가되었습니다.


애플리케이션을 실행한 후, 유효하지 않은 JWT 또는 만료된 JWT를 Authorization header에 추가해서 request를 전송하면 아래의 [그림 4-27]과 같은 response를 전송합니다.



[그림 4-27] AuthenticationEntryPoint에서 전송된 Error response


또한, 권한이 없는 리소스에 request 전송 시, 아래의 [그림 4-28]과 같은 response를 전송합니다.



[그림 4-28] AccessDeniedHandler에서 전송된 Error response


드디어 JWT에 대한 기능이 완성되었습니다. 👏👏

JWT는 웹 애플리케이션에 간단하게 적용할 수 있지만 웹 애플리케이션 보안에 있어 굉장히 중요한 역할을 합니다.


따라서 이번 시간에 여러분들이 애플리케이션에 JWT를 직접 적용해 봄으로써 가까운 미래에 있을 여러분들의 프로젝트 또는 실무에 JWT를 직접 응용하는 데 도움이 되길 바랍니다.


만약 실무에서 Username/Password 기반 로그인 인증과 JWT 자격 증명에 대한 기능이 추가되었다면 여러분들이 해야 할 작업이 하나 더 있습니다.

바로 Spring Rest Docs를 이용해 API 문서를 업데이트하는 것입니다.
Spring Security를 통해 보안이 적용된 상태에서 API 문서를 업데이트할지는 여러분들의 몫으로 남겨두도록 하겠습니다. ^^



핵심 포인트
JWT는 JWS(JSON Web Token Signed)라고도 불린다.

SecurityContext에 Authentication을 저장하게 되면 Spring Security의 세션 정책(Session Policy)에 따라서 세션을 생성할 수도 있고, 그렇지 않을 수도 있다.

SecurityContext에 클라이언트의 인증 정보(Authentication 객체)가 저장되지 않은 상태로 다음(next) Security Filter 로직을 수행하다 보면 결국에는 AuthenticationException이 발생하게 되고, 이 AuthenticationException은 AuthenticationEntryPoint가 처리하게 된다.

AccessDeniedHandler는 인증에는 성공했지만 해당 리소스에 대한 권한이 없으면 호출되는 핸들러이다.



심화 학습
AuthenticationEntryPoint에 대해서 더 알아보고 싶다면 아래 링크를 참고해 주세요.

https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/AuthenticationEntryPoint.html
AccessDeniedHandler에 대해서 더 알아보고 싶다면 아래 링크를 참고해 주세요.

https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/access/AccessDeniedHandler.html



